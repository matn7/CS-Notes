#######################
# Behavioral Patterns #
#######################

# Strategy Pattern

* String Sorting
Java has standard way of handling sorting.
Create a lot of algorithm each implements the interface Comparator<String>
Any object that implements this interface has a method that takes in 2 Strings, and specified which comes first.
int compare(String s1, String s2), by returning -1,0,1 whether the first string is less than, equal to, more than the second
Each algorithm can specify its own logic to determine this order.
Sort using
Collections.sort(List<String> list, Comparator<String> comparator).
Strategy Pattern is used to specify a behavior "how to sort".
Strategy Pattern uses composition Member variable), over Inheritance (Interfaces or abstract classes), in modified class
Idea of Strategy Pattern is make it easy to vary the behavior ofa class at runtime, and do so using composition rather
than inheritance.

* Dependency Injection
Is widely used and very powerful technique of setting up member variables of complicated classes on fly.
It is fundamentally similar to the strategy pattern.

Dependency injection allows a class which uses many different services to not know about the instantiation
of each of this services, instead its member variables which are these services are injected into the class
this allows the instantiation of the class to be simple and it is a injector which holds all the complicated
information of what class to instantiate and inject into a particular class.


# Template Pattern

Frameworks are complicated group of classes that do bunch of stuff. Complicated collections of interconnected classes.
As a programmer your job is to plugin little bits of code that customize what the framework does.
Framework widely use something known as the Dependency Inversion Principle.
Abstract base class is a template for the complicated operations.
The abstract (unimplemented) methods left for the programmer are called hooks.
Basic point of template pattern, specify a complex set of steps, and have client code plugin specific
implementations of individual steps.
Allow subclass to customize parts of an algorithm, but force them to adher to the overall algorithm.
Specific bit that programmers need to do using frameworks is called an Event.
And the place where you the programmer, stand by waiting fr the envent and decide how to react to the event is called Listener.
In API JavaFX framework.


# Iterator Pattern

Collections are containers which means that they hold collections of data.
A List is a collection of values in order,
A Set is a collection of values in no particular order.
A Map is a collection of key value pairs.
Every java collections implements the interface Iterable<T>. This interface has a single method Iterator iterator().
Every java collections offers a way to get a coresponding iterator object.
An iterator offers a way to get in sequence every element of a collection. This is completely independent of how the collection
is implementec. hasNext(), next(), remove() methods of Iterator.
Classes which implements the Iterable<T> interface can be used in for-each statements in code.
An iterator is a simple way of allowing some external code to loop through a collection of data without
assignment privileges.

External iterators have advantages that because the iterator sits outside a collection. It is easy enough to define different
iterators for collection.

Internal iterators


# Observer Pattern

MVC + Observer = UI
All UI's.
Variables announce changes to their states. Other object subscribe to listen to these changes.
Object that publish these updates are called PUBLISHERS (a button).
Objects that subscribe to listen to these changes are called SUBSCRIBERS (UI app).
The code that gets executed when an update is published is called CALLBACK (Display popup when button is clicked)
Publishers announce different types of updates - each of which is reffered to as AN EVENT (button clicked, hover)
Collback belongs to subscriber object but is called by the publisher object when the event occurs.
Another example capturig mouse clicks. JComponent alows programers to listen in on mouse event.
Implement mouseadapter interface. Listen via addmouselistener method, which is present in every UI Element.
Within these methods, it is possible to examine if the mouse event was popup trigger (right click).
Listener - the command object with the code that gets executed when something happens.
Subscriber/observer - The object that wait for something to happen. The object that register to be informed of changes.
    Part of controllers and model in MVC.
Publisher - The object that announces that somethig has happened. Are part of views.
Event - The something that happens.
Observer pattern and command pattern are related, the publisher maintains a list of command objects and executes their code when an event occurs.
The command objects are part of the controller, and the observer objects are part of the view.

- If object change state it notifies other object about this
- subject : object that about to change its state
- observer : object that receives notification about changes
Defines relation between object one to many, which tells that when one state of object change, others are automatically
notify about that and properly actualize.
Behavioral Pattern
-Each implementations must share common interface
-Havily used in UI and frame systems
-Often calls listener pattern

# Command Pattern

Class that has just one method. It encapsulates all the state needed for that one method to do its thing.
Classes with one methods menus, threading, indomanagers
Command objects lie at heart of the command pattern. A command object has a single method, and whether state is
needed for that method to do its thing.
A command object separates an action from the execution of that action.
A command objects separates the execution of an action from the action itself.
The Client - the user who triggers the execution of the action
The Invoker - the button which is clicked by the client to trigger execution of the action
The Receiver - the display area which is acted upon by the action.
The Trigger that causes the action to be executed is called AN EVENT.
A class with a single method is essentially an action

Example Lambda function: functional constructors in an object oriented language.
Anonymous classes (listeers, threads) are an excellent way to encapsulate little bits of behavior into objects.
Very high proportion of anonymous classes siply consisted of - objects that implement an interface with just one function.
Example anonymuus class Comparator is an interface with a single method, compare.
Such interfaces are called "Functional Interfaces" or "Single Abstract Method Interfaces".
Interfaces with just one method can actually be encapsulated using single functions - no real need for them to be encapsulated using classes.

LAMBDA FUNCTIONS ARE SIMPLY ANONYMOUS FUNCTIONS.
These anonymous function objects are often called "closures".
In a for loop it is impossible or at least very complicated to parallelize the loop acress multiple different CPUs.
Lambda functions are functional programming area a natural way to parallelize computing across CPUs.
Divide up the list you are iterating over, and send parts of the list, along with the lambda function,
to different cloud nodes, then aggregate the results. This is exectly what cloud computing is all about.

Lambda functions are powerful when output of one is fed as the input of the next.
Lambda functions represent the action.
Java has added exactly this functionality, using "AGGREGATE OPERATIONS".
Filter, Map and Foreach are standard aggregate operations in functional porgramming.
Call ".stream()" method on any collection to get an object of type stream on which aggregate functions can be applied in sequence.
Stream can be imagined as stream of values, where each value is being subjected to an operation like MAP, FOREACH, FILTER.

Maps is an aggregate operation that takes a lambda expression, applies it to every element of input stream,
and send the results out as the output stream.

Filter is an aggregate operation that takes in one lambda expression that encapsulates a condition, applies
it to every element of an input stream, every element that satisfies the condition is placed on the output stream.

Foreach is an aggregate operation that takes a lambda expression and applies to each element of an
input stream, but does not produce an output stream.
Foreach is used for operations like printing to screen or saving to file, where it makes no sense to produce output stream.

Second example threading.
In Threading we define the action that we would like the new thread to undertake. And wrap the action
in the body of a object that implements an interface with just one method.
Define command object Runnable. Receiver is a screen, the invoker is a Thread object. Client calls start
on that object to trigger the execution of the action.
The code to be executed on different thread is encapsulated in a command object.

Third Example undo and logging


# The Chain Of Responsibility Pattern

Allow more than one receiving element to handle request. The sender interacts with only first receiver in a queue.
Handle Exceptions.
Handle mouse clicks. UI applications often are built on the composite pattern,
meaning that windows contain other windows. The nested windows pass the mouse click action down from one to another
until some windows has a handler from a mouse click.
Some events need to be handled by one of multiple objects, and it is not known which one object specifically will know how to do
what's needed.


# Memento Pattern

Object sometimes need to know how to save their state and go back to that saved state.
Example Serialization. Ability of an obect to save it's state. If an object can save its state, a relatively
easy way to implement undo is to have the object "RESET" to previously saved state.
Java has build in memento pattern via the Serializable interface.
Any class that implements Serilizale and in which all member variales are serializable can be written to file or
read from file with minimal effort.
The Serializable interface has 2 methods - read object and write object.
If member variable belongs to a class that does not implement serializable, you can just mark the member as
"TRANSIENT" meaning that Java should not write out its value to file.
Serializing and de-serializing meant laying out the object, 1 member variable at a time.
Objects marked Serializable know how to save their state to file, and this is an implementation of Memento Pattern.
A lot of build in objects are already Serializable.

Saving to file Serializing
FileOutputStream
ObjectOutputStream
writeObject

Reading from file Deserializing
FileInputStream
ObjectInputStream
readObject


# Visitor Pattern

Example object that knows how to traverse the tree of a composite object. The visitor object sits outside
the composite object which allows us to have any number of visitor classes for a given composite object.
Each visitor object define its own traversal (DEPTH-FIRST, IN-ORDER, ...) of the composite tree, as well
as its own unique operation on each node.
Using visitor object along with a composite object makes it easy to customize the process of traversal,
and to add new operations.
The Visitor pattern is a way to do something with each node of a Composite object.
Visitor + Composite = Decorator.


# The State Pattern

This pattern is used to encapsulate varying behavior for the same object based on its initial state.
This can be cleaner way for an object to change its behavior at runtime without restoring to large
monolithic condition statements and thus imporve maintainability.

Example Java Media Classes
Media encapsulates an audio or video file. Has duration, tracks, metadata.
MediaPlayer allows the user to do all of things user do with the media. Play, Pause, Change Volume.
MediaView the view actually appears on screen. State pattern is life saver where classes have discret states and
transitions between them.
 Basic of State Pattern. State Machines have discret states, each state can be represented by a member variable.
All these member variables implement a common interface.


# Mediator Pattern

When class hierarchies got too complicated, they can be simplified using Mediator.
A mediator object decouples peer objects on a hierarchy from needing to know all about each other.
Examples all UIs.
The frame acts as the mediator so that none of individual UI Elements need to know about each others.
The UI Elements are reffered as COLLEAGUES.
Collages are entirely decoupled from each other.











