#######################
# Structural Patterns #
#######################

# Decorator Pattern

Dynamically add responsibilities to objects
For example File API in Java
Adding new functionality to existing class should be easily done while extending the class
inherited from it we use it within a composite or any other way. You should not force user
to modify this class in order to change functionality, Java does it via Decorator Pattern.

All input streams derive from common abstract class InputStream which contains standard operations shared by all streams.
read(), close(), reset()
There is a separate class deriving from input stream
FileInputStream, ObectInputStream, AudioInputStream.
InputStream object can be chained to get more input stream objects, this chaining of objects
all of which descend from the same interface or abstract based class.
It is crucial that the decorators be independent of each others. No decorator should know the
exact type of another, only that they all have a common interface or abstract base class.
Use decorator when you have a lots of objects each with a specific behavior indepandent of all others.
Decorator objects are usually chained together, and should never know any details of other objects in the chain


# Adapter Pattern

Adapter is device that converts attributes of one electrical device or system to these of an otherwise incompatible device or system.
An adapter takes in an object that implements an interface and gives out an object that implements different interface.
In Java convert array on list, JavaFX Framework tables and charts.


# Facade Pattern

A facade provides a simple interface for a larger body of complicated code. Multiple systems can work together
behind the facade, however the user will see only the simple interface.
In Java API URL to download data. Java NET library. Which manages complecity, assumes that you don't know or care how a content from
URL are obtained. Java abstracted all that process for you, assmes that you dont know much about networking or stuff.
Facasde are in Reflection, Networking, Database access, Madia Players.
Basic point in facade is a wrapper to abstract the complexity of a group of interconnected classes.
What motivates a Facade pattern, classes should know as little as possible about other classes they use, relay on abstractions-interface
not implementations, loosely coupled code is preferable to tightly coupled.


# Composite Pattern

Objects are created from objects "like themselves" (in example share the same interface).
Create a class hierarchy to reflect dependent objects, all of which ahare a common interface.
Allow the user to interact with every dependent object in a tree like hierrchy of objects.
The Composite Pattern is the basic of most UI Containers in Java.
Swing Containers.
Each UI has a JFrame -> A JFrame contains many UI Elements like JComponent -> JComponent includes
JMenu, JTreeView, JFileChoser ...
Each JComponent contains any number of children, which are also JComponent objects.
The User interacts both with the root of this tree of JComponent and with individual JComponents.
Example Animations


# Flyweight Pattern

A flyweight is an object that minimalizes memory use by sharing as much data as possible with other similar objects.
It is a way to use objects in large numbers when a simple repeated representation would use an unacceptable amount of memory.
Strings in Java are "IMMUTABLE", which means that Java only stores one copy od each distinct string value.
To test if two String are the same simply test if they are the same object. This is example of flyweight pattern.
Some objects strings for instance should be represented by immutable instances.
The flyweight pattern creates new objects only for unique values all instances with the same value
reference the same underlying immutable object.

Multithreading
Flyweight Pattern must be used carefully in multithreading code else two thread might simultaneously create
flyweight for the same distinct value without knowing about each others instance.
Place the instantiation of flyweight in a single threaded bit of code, for instance by using synchronized keyword.
This might cause performance hit. You can choose to simply allow multiple flyweights for the same distinct value.
But be sure to override "EQUALS" function in the flyweight so that it compares value, and not object identity.
By default "EQUALS" method test for object identity it return true if and only if the 2 objects are literally the same
(point to the same location in memory).
In flyweight we need this method to return true if the 2 objects have the same value, even if they are
actually different objects.


# Bridge Pattern

When class hierarchies got too complicated, they can be simplified using bridges.
The Bridge Pattern uses composition ("has a") as a bridge between two independent class hierarchies.
Decouple an abstraction from its implementation so that the two can vary independently.
The Bridge uses encapsulation, aggregation and can use inheritance to separate responsibilities into differet classes.
Because bridge and strategy both plug in member variables to determine behavior - thus they prefer
composition ("Has a") over inheritance ("Is a").


# Proxy Pattern

Proxies are objects that "stand in" for other objects.
Proxy objects control access or abstract functionality of other objects.
Example RMI (Remote Method Invocation). RMI was a way in Java to make method calls to code that resided
on a different machine.
RMI was important step in the evolution of distributed computing, and was build atop of Proxy Pattern.
When you made an RMI call, you would get a Proxy Object a stand-in for the actual object that resides
on a different computer.
The underlying principle of the proxy pattern is that one object controls access to another.
This controlling object is called proxy or surrogate. In RMI, a proxy is needed to abstract complex dealing
with an object on another machine.
Proxies might be useful if expensive calls can be cached.
The Proxy for a command object could maintain a cache where the key=set of parameters from each call
to the command, and value=Result of that command.
This techniques is called MEMOIZATION, and can lead to big performance savings.

















