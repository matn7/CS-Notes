#######################
# Creational Patterns #
#######################

# Factory Pattern

Provides one of the best ways to create an object. In Factory pattern create object without exposing
the creation logic to the client and refer to newly created object using a common interface.
Factory pattern on database connection.
Create interface IDataBase common across all databases. Create database classes MySql and Oracle.
Each of these DB implements IDataBase interface.
To make switchover between classes use config file and reflection mechanism.
Config file is text file used to specify inputs that the application uses at runtime. Code now does not to be
recompiled and re released.
IDataBase database = DatabaseFactory.getDatabase()

Basic idea of factory pattern is to decouple implementation of a class from its use.
Create a mechanism for many alternative implementations to be instantiated from a single method.
Factory objects create a dingle family of classes.


# Abstract Factory

If we want to use factory pattern without reflection.
Have two factory classes MySql and Oracle, each of these factory classes only returns database objects of
a specific type. Most implementation of these two classes are shared, so place shared code into abstract base class.
The implementation details of how an object of database type is instantiated is completely hidden and decoupled from the user.
Use abstract factory to create families of related classes.
The abstract factory pattern is useful when we don't want to use reflection and also if we have different
versions of oracle and MSSQL Database, or if we have different implementations not just of database
but also of command and connection for MS-SQL Oracle.
Abstract factory pattern is a way to create groups of related classes that implements different interfaces.
Abstract factory object create entire families of classes. Is useful to create families of product while
abstracting away CREATION and IMPLEMENTATION details from the user.


# Singleton Pattern

One object of particular class is needed. Device Drivers, Registry Settings. Singleton objects
make sense when the state of an object consumes a lot of memory, and just one version of that state
is sufficient for entire application.
Singleton objects must satisfy two attributes: Exactly one instance of object should exists.
Everyone should be able to access it, global point of access.
Standard parts of implementing the Singleton are Private Constructor, Synchronized getter for the Singleton.

Double checked locking in software engineering is software design pattern used to reduce the overhead of acquiring a lock,
by first testing the locking creation, without actually acquiring the lock.

Singleton classes should never be subclassed or extended.

Make sure your singleton object can't be cloned. Make sure that singleton class does not implement cloneable, or if
it does override the clone() method to throw Exception.


# Builder Pattern

When you know exactly what object you need use a constructor.
When you don't know exactly what object is needed but you want to be able to decide at runtime from a family of objects.
Use factory pattern.
When you know beforehand exactly what object you need but that object has to be build up slowly as user inputs comes in.
Use Builder pattern.
In API StringBuilder for example.
Allow object to be created in a step-by-step manner.
Abstract the user of a class from implementation details of the objects of the class.


# Prototype Pattern

When an object if class can be created as a clone of another object of that class.
Class has a constructor that takes in another object of the same class.
Such constructor is called a copy constructor.
In Java this functionality is effected not via constructor, but rather via the clone method of the interface Cloneable.
To clone object: Clone the parent portion on object, clone each member variable of this object.
When a class inherits from another class, every object of the child class has an actual copy of the parent inside.
The child class may not know how to clone the member variable of the parent class. So the first line of the clone
method of any class should always be super.clone()
The implication is that an object can only be cloneable if all its parent classes are cloneable.
Two types of copy in Java. Shallow Copy, Deep Copy.
The prototype pattern is useful whenyou don't really know what type of object you are seeking to create.
Problem of Java Cloneable interface. The .clone() method exists in the Object base class, not inside the Cloneable interface.
The Cloneable interface does not contain any methods at all. Any object that implements this interface must override the .clone()
method of the Object class, but there is no compile time way to force to do so.
















