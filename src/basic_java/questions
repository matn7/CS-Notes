# ClassCastException

* When references to objects ponits to objects different classes
* When argument if wrong type, method compareTo should throw exception
* No expliit casting
* Try add wrond data type
* SerialVersionUID


# Constructor Chaining

* Call in the same class this()
* Call from parent class super()
* Use to execute more tasks in one constructor
* Improver readability of code


# Overloading

* Compile time polymorphism
* Use the same method name but with different arguments


# Overriding

* Runtime polymorphism
* The same method name with exactly the same arguments


# final

* Value of member variable cannot be changed
* Object reference cannot be changed
* Class cannot be inherited
* Method cannot be overriden


# finally

* Try, catch, block. Stuff between {} in finnaly always be executed, even when in try return statement
* Finnaly want execute. Program crasch before go to this block, or in try System.exit(0)


# finalize

* JVM call this method when GC is about to e called


# == vs equals

* == check wether object are the same (point to the same place in memory, the same object)
* .equals() when compare content of objects


# Class Loaders

* Bootstrap Class Loader
* Extension Class Loader
* System Class Loader


# SerialVersionUID

* Mark added to class to during deserialization, reconstruct good class. Useful when there is some class hierarchies
parent class, child class


# hashCode, equals

* You must override hashcode in every class that overrides equals. Failure to do so affect working with hashbasec collection
HashMap, HashSet


# String

* Immutable and final
* Thread safe - prevent from change cach
* String pool cache (optimization)
* Hash codes - keys in hashCodes are Strings


# Interfaces

* All methods public abstract
* All properties public static final
* Implement interfaces, want to imitate behavior of class
* Use to impose behavior on other classes
* You can implements more than one interface (impose behavior), example implements Comparable interface to extort
  sorting behavior


# Class Object

* Parent class of all classes
* hashCode
* equals


# Abstract class and methods

* Cannot instantiate abstract class
* Are needed during inheritance
* Whant something to be overriden to not forget about it later
* Additional responsibilities added to class


# OOP

* Objects - containers that keep variables functions thematically connected to each others, to use it easier later
* Classes - Frame to build instances of objects
* Objects have, properties, methods
* Constructor - reserve space in memory for object


# Serialization

* Abstract class - high level class, by whom inherits
* Data serialization allows to know about all references (extends)
* Serialized object will be read to file. They will acquire some special identification number, object will use this
  number to other objects
* To perform serialization class need to implements Serializable interface
* Serializable marker interface (without method), safety guard to make sure you know what you are doing.
* transient data that we dont want to be serialized
* Fragile data should be marked as transient, or should not implement Serializable


#########################
# Garbage Collection GC #
#########################

* Java provides automatic memory management through a program called Garbage Collector. "Remove object that are not use"
* live object = reachable (referenced by someone else)
* dead object = unreachable (unreferenced)
* Objects are alocated in the "heap" of java memory
* static members, class definition are stored in "method area" Permgen/Metaspace
* Garbage Collection is carried out by a daemon hread called "Garbage Collector"
* Force GC to happened System.gc (no guaranteed)
* Wen failed to alocated bcause of full heap. Error message java.lang.OutOfMemoryError

* Gargage Collector involves
    - Mark : go through all program structure, mark reachable objects as live
    - Delete/Sweep : Delete unreachable objects
    - Compacting : Compact memory by moving around objects

* Typed of Garbage Collector
    - Serial Collector : Runs on single thread, useful in basic applications
    - Concurrent Collector : GC execute as application runs, not wait the old generation to full stop the world
      execute only during mark/re-mark phase
    - Parallel Collector : Uses multiple CPUs to perform GC. Multiple threads doing mark/sweep. Does not start until
      heap is full/near-full. "Stop the world" when runs.

* Use Concurrent collector, when there is more memory, high number of CPUs, short pauses required
* Use paraller collector, when there is less memory, lesser number of CPUs, high throughput required, pauses are OK

java -XX:+UseSerialGC
java -XX:+UseParallelGC
java -XX:+UseConcMarkSweepGC


###############
# Concurrency #
###############
* fail-safe do not throw ConcurrentModificationException
* fail-fast throw ConcurrentModificationException

# Concurrent Collections

    # ConcurrentHashMap
    * Full concurrency during retreival
    * Reads can happen fast, while writes require lock
    * Whole table is not locked only segment is locked
    * Iterations do not throw concurrent modification exception
    * Null key not allowed
    * Operations are atomic

























