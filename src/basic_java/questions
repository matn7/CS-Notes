@Described terms:
ClassCastException
Constructor Chaining
Overloading
Overriding
final
finally
finalize
== vs equals
Class Loaders
SerialVersionUID
hashCode, equals
String
Interfaces
Class Object
Abstract class and methods
OOP
Serialization
What is the difference between composition and inheritance ?
How are the Strategy Pattern and Dependency Injection related ?
Reflection
Volatile


# ClassCastException

* When references to objects ponits to objects different classes
* When argument if wrong type, method compareTo should throw exception
* No expliit casting
* Try add wrond data type
* SerialVersionUID


# Constructor Chaining

* Call in the same class this()
* Call from parent class super()
* Use to execute more tasks in one constructor
* Improver readability of code


# Overloading

* Compile time polymorphism
* Use the same method name but with different arguments


# Overriding

* Runtime polymorphism
* The same method name with exactly the same arguments


# final

* Value of member variable cannot be changed
* Object reference cannot be changed
* Class cannot be inherited
* Method cannot be overriden


# finally

* Try, catch, block. Stuff between {} in finnaly always be executed, even when in try return statement
* Finnaly want execute. Program crasch before go to this block, or in try System.exit(0)


# finalize

* JVM call this method when GC is about to e called


# == vs equals

* == check wether object are the same (point to the same place in memory, the same object)
* .equals() when compare content of objects


# Class Loaders

* Bootstrap Class Loader
* Extension Class Loader
* System Class Loader


# SerialVersionUID

* Mark added to class to during deserialization, reconstruct good class. Useful when there is some class hierarchies
parent class, child class


# hashCode, equals

* You must override hashcode in every class that overrides equals. Failure to do so affect working with hashbasec collection
HashMap, HashSet


# String

* Immutable and final
* Thread safe - prevent from change cach
* String pool cache (optimization)
* Hash codes - keys in hashCodes are Strings


# Interfaces

* All methods public abstract
* All properties public static final
* Implement interfaces, want to imitate behavior of class
* Use to impose behavior on other classes
* You can implements more than one interface (impose behavior), example implements Comparable interface to extort
  sorting behavior


# Class Object

* Parent class of all classes
* hashCode
* equals


# Abstract class and methods

* Cannot instantiate abstract class
* Are needed during inheritance
* Whant something to be overriden to not forget about it later
* Additional responsibilities added to class


# OOP

* Objects - containers that keep variables functions thematically connected to each others, to use it easier later
* Classes - Frame to build instances of objects
* Objects have, properties, methods
* Constructor - reserve space in memory for object
* Creating an object from a class ins called instantiation


# Serialization

* Abstract class - high level class, by whom inherits
* Data serialization allows to know about all references (extends)
* Serialized object will be read to file. They will acquire some special identification number, object will use this
  number to other objects
* To perform serialization class need to implements Serializable interface
* Serializable marker interface (without method), safety guard to make sure you know what you are doing.
* transient data that we dont want to be serialized
* Fragile data should be marked as transient, or should not implement Serializable


# What is the difference between composition and inheritance ?

Composition refers to defining behavior by member variables a class includes
Inheritance refers to defining behavior by the interfaces or classes that a class inherits from
Composition = "has-a", Inheritance = "is-a"


# How are the Strategy Pattern and Dependency Injection related ?
Each defines behavior by setting member variables of a class


# Reflection

Reflection is a way to invoke methods of objects on the fly at run-time.
Reflection is slow and complicated. Method call via reflection may take 10x longer than usual.
Instantiation an object from a name of a class.
Reflection is the ability at runtime to actually create objects of classes, invoke methods, manipulate metadata
Type introspection is the ability at runtime to explore the type of an object.
Refletion drawbacks: complectit, performance overhead, security consideration, violation of abstraction.
Reflection is good for unit testing jUnit.


# Volatile

* Declaring variable volatile means the value of this variable will never be cached thread locally.
  All reads and writes will go straight to main memory. Access to the variable acts as through it is
  enclosed in a synchronized bock, synchronized on itself.
  Slower than cach, make sure value be read every time.

# Synchronized

* Every objects in Java has a lock associated with it.
  This lock is called the intrinsic lock or monitor. It is possible to specify that only one thread can
  execute a section of code once it has acquired the lock on same object.
  If some other thread currentl holds that lock, the current thread must waits its turn.
  This is achieved using synchronized keyword.
  Using right making a method synchronized can help eliminate thread interference and memory consistency error.
  Making method synchronized is a shortcut to making the entire body of the method as synchronized on "this".
  If we use synchronized we don't need to use volatile keyword.


#########################
# Garbage Collection GC #
#########################

* Java provides automatic memory management through a program called Garbage Collector. "Remove object that are not use"
* live object = reachable (referenced by someone else)
* dead object = unreachable (unreferenced)
* Objects are alocated in the "heap" of java memory
* static members, class definition are stored in "method area" Permgen/Metaspace
* Garbage Collection is carried out by a daemon hread called "Garbage Collector"
* Force GC to happened System.gc (no guaranteed)
* Wen failed to alocated bcause of full heap. Error message java.lang.OutOfMemoryError

* Gargage Collector involves
    - Mark : go through all program structure, mark reachable objects as live
    - Delete/Sweep : Delete unreachable objects
    - Compacting : Compact memory by moving around objects

* Typed of Garbage Collector
    - Serial Collector : Runs on single thread, useful in basic applications
    - Concurrent Collector : GC execute as application runs, not wait the old generation to full stop the world
      execute only during mark/re-mark phase
    - Parallel Collector : Uses multiple CPUs to perform GC. Multiple threads doing mark/sweep. Does not start until
      heap is full/near-full. "Stop the world" when runs.

* Use Concurrent collector, when there is more memory, high number of CPUs, short pauses required
* Use paraller collector, when there is less memory, lesser number of CPUs, high throughput required, pauses are OK

java -XX:+UseSerialGC
java -XX:+UseParallelGC
java -XX:+UseConcMarkSweepGC


###############
# Concurrency #
###############
* fail-safe do not throw ConcurrentModificationException
* fail-fast throw ConcurrentModificationException
* volatile - value read always from main memory no cache
* synchronized - acquire intrinsic lock on object. Only one object can execute this part of code.
* join() - wait until other thread finish executng


# Process and threads

* In concurrent programming two units of executio process and treads.
* Processing time for a single core is shared among processes and threads, time slicing

* Process : Has a self contained execution environment. Private set of runtime resources.
  Each process has its own memory space. Process can communicate with each others IPC.

* Threads : Lightweight process. Creating a new thread requires fewer resources than creating a new process.
  Exists within a process. Every process has at least one thread.

* join() : method wait until thread to finish

* threads prioritity : importance of a thread to the sheduler. Lower prioritity thread tend to run less often.
  setPrioritity(), getPrioritity(). MAX_PRIORITITY, NORM_PRIORITITY, MIN_PRIORITITY

* yield() : this static method is essentially used to notify the system thet the current thread is willing to
  give up CPU for a while, but sheduler can immediately pick them back. Is put back into the ready queue of the processor,
  and waits for it next turn.


# Start Thread

* Extends Thread - override run() method

* Implements Runnable - override run() method, pas Runnable object to Thread class constructor. Call start method
  on thread object.

* Executor Service - dynamically reuse thread. Check if threads are already working.
  - Executors.newCachedThreadPool() return an executor service that can dynamically reuse threas.
    Before starting a job, it going to check wether there are any threads that finished the job if so reuse them.
    If no create new one, good for processor effective solution
  - Executors.newSingleThreadPool() uses single thread for the job.
  - Executors.newFixedThreadPool() maximize the number of threads. If all the thread are busy we have to wait
    for one to terminate.

  - executorService.execute(Runable)
  - executorService.execute(Callable or Runnable)


# Concurrent Collections

    # ConcurrentHashMap
    * Full concurrency during retreival
    * Reads can happen fast, while writes require lock
    * Whole table is not locked only segment is locked
    * Iterations do not throw concurrent modification exception
    * Null key not allowed
    * Operations are atomic

    # BlockingQueue
    * Interface that represents a queue that is thread safe. put(), take()

    # DelayQueue
    * Like BlockingQueue that implements Delay interface. Cannot put null into it.

    # PrioritityBlockingQueue
    * Iplements Comparable interface. Determine what will be the order of a Queue.


# Threads complications

* Thread interference and memory consistency errors
    - If two thread access the same variable, it is possible for them to get in each others way
      For example tow threads incremanting the same variable at the same time.
      To fic this make sure that section of code is only accessed by one thread at a time, by using synchronized keyword for example.
      But this slows down performance, and can lead to thread contention issues (starvation, livelock, deadlock)

* Thread Contention
    - Deadlock : two thread each is blocked by a lock held by the other
    - Livelock : two thread's don't deadlock, but keep blocking on locks held by each other, neither can progress
    - Starvation : Same thread keep acquiring locks greadly. And cause other threads to be unable to get anything done.


# Semaphores

* Variables that are used to controlling access to common resources, important in OS.
  is a record of how many units of particular resource are available.
  Semaphores track how many resources are free, it does not keep track of which of the resources are free.
  Metexes are binary semaphores. Mutex has a concept of an owner. Only process that locked a mutex is supposed to unlck it.
  Methods acquire() if permit is available take it, release() add a permit.


# Callable and Future

* Returns something from a thread implements Callable instead of Runnable.


# Thread States

* Runnable - create a new thread and call start method
* Blocked - enter synchronized block, lock
* Waiting - after wait()
* Terminated - run method is over


# Concurrent Libraries

    - CountDownLatch : Used to synchronize one ore more tasks by forcing them to wait for completion of a set of operatios
      being performed by other tasks. Give initial count to count down latch object and task that calls await() on that
      oject will block until count reaches zero. The count cannot be reset. Typically use is to divide a problem into "n"
      independetly solveable tasks and create a CountDownLatch with value of "n".
      When each task is finished it calls countDown on Latch. Task waiting to solve call await() on the Latch to hold
      themselves back until it is completed.

    - CyclicBarrier : Used in situation where you want to create a group of tasks to perform work in parallerl plus wait
      until they are still finished before moving on to the next step, like join or countDownLatch.
      Can be reused.

###################
# Design Patterns #
###################

* Design Patterns are canonical solutions to recuring problems
* Creational Patterns "How should object be created"
    - Factory, AbstractFactory, Singleton, Builder, Prototype, Dependency Injection
* Behavioral Patterns "How should object behave and interact with each other"
    - Strategy, Template, Iterator, Command, Chain of Responsibility, Memento, Visitor, State, Mediator, Observer
* Structural Patterns "How should classes behave and interact with each other"
    - Decorator, Adapter, Facade, Composite, Flyweight, Bridge, Proxy
* Concurrency Pattern "How should specific situation be handled in multithreading"
    - Double checked locking
* Model View Controller "Architectural pattern"

* Libraries and Frameworks are both code written by others that we can use.
* Design Patterns are proven ideas for solving common problems.
* Code usually calls libraries and is often called by frameworks, but is stractured using Design Patterns


# Creational

* How objects are constructed
* Decouple the construction of an action from its use
* Hide implementation of an object only reveal its interface
* Defer instantiation until run time
* Families of related objects that must be used together
* Allow creation of finite number of instances


# Behavioral

* How do objects behave and interact with each other
* How logical unit (classes) as whole interacts with the outside world
* Iterator pattern - here logical unit includes 1 class Iterator class. This pattern governs how the
    is used by the client (the outside world)


# Structural

* How classes within the logical unit interacts with each other
* MVC pattern - logical unit includes 3 classes model, view, controller
    The pattern governs how the Model, View, Controller interact with each other
    If the interaction etween the M, V, C were change, the UI would not look or behave any different !


# Design Principle #1 : Relay on Interfaces, not implementation

"Program to an interface not implementation" decorator, iterator, adapter

Interface is a surface that a unit offers to outside world.
That unit could be a single class, or even be a collection of classes.
The implementation is a guts of that unit.
Never get assumption about content of any unit.
ArrayList<String> list = new ArrayList<>(), wrong
List<String> list = new ArrayList<>(), correct


# Design Principle #2 : The Open / Close Principle

"Classes should be open for extension but closed for modfication"

Once you have written a class, it's done. Never add enything to it after that.
No new member variables, no new methods, no new interfaces implemented, No modification.
But other code should be able to use your class in new ways, New applications via extension.

* Inheritance, template pattern
    - If you structure your code into abstract base class, other classes can find
      new way to use it via Inheritance

* Delegation, observer, MVC, Chain of Responsibility
    - If you fire events and expose properties, other code can listen in, and use your code via Delegation

* Composition, strategy pattern
    - If you take in member variale to determine behavior, you allow extension via Composition


# Design Principle #3 : Principle of Least Knowledge

"Only talk to friends, don't talk to strangers"

Only make method calls to friends.
friends - object passed in as parameter to methods of your classes. Object created insde your class.
Code should never include multiple '.' operators in the same function call.
int friendNumber = media.getRelatives().getFriend(), not OK
int firndNumber = media.getFriend(), OK
But this rule is not always a case.
Summarized, each unit should have only limited knowledge about other units. Each unit should only tolk to its friend.


# Design Principle #4 : Dependency Injection

"Depend on abstraction never on details"
Used technique to set member variables of objects on the fly.

# Design Principle #5 : Hollywood Principle

"Don't call us we will call you"
Class notifies other class of changes when they occurs via events or messages.
Idea high-level component calling low-level is used components in frameworks.





















