# ClassCastException

* When references to objects ponits to objects different classes
* When argument if wrong type, method compareTo should throw exception
* No expliit casting
* Try add wrong data type
* SerialVersionUID


# Constructor Chaining

* Call in the same class this()
* Call from parent class super()
* Use to execute more tasks in one constructor
* Improve readability of code


# Overloading

* Compile time polymorphism
* Use the same method name but with different arguments


# Overriding

* Runtime polymorphism
* The same method name with exactly the same arguments


# final

* Value of member variable cannot be changed
* Object reference cannot be changed
* Class cannot be inherited
* Method cannot be overriden


# finally

* Try, catch block. Stuff between {} in finally always be executed, even when in try return statement
* Finnaly does't execute, Program crash before go to this block, or in try System.exit(0)


# finalize

* JVM call this method when GC is about to e called


# == vs equals

* == check wether object are the same (point to the same place in memory, the same object)
* .equals() when compare content of objects


# Class Loaders

* Bootstrap Class Loader
* Extension Class Loader
* System Class Loader


# SerialVersionUID

* Mark added to class to during deserialization, reconstruct good class. Useful when there is some class hierarchies
parent class, child class


# hashCode, equals

* You must override hashcode in every class that overrides equals. Failure to do so affect working with hashbase collection
HashMap, HashSet


# equals

Check whether one object can be equal to another. Equals method implemented in Object class, check whether two
references to object are identical. Override equal method if you want to check equality based on state of object.
Two object are equals when they have the same value.
Checks that we need to perform.
// Check whether objects are identical
if (this == otherObject) return true;
// False if parameter is null
if (otherObject == null) return false;
// Check whether otherObject is the same instance as this), se getClass or instanceof
if (getClass() != otherObject.getClass()) return false;
// Check values
return Ojects.equal(some, other.some) && ...;


# hashCode

Hash is integer number that identify an object. Hash should be different.
If x and y are different objects, in big probability x.hashCode and y.hashCode should also be different.
hash = 31 * hash + chartAt(i)
HashCode must be compatile.
if x.equals(y) return true, x.hashCode == y.hashCode.
If you change equals method you have to change hashCode also. Failure to do so results in objects put in hash based
data structures HasSet, HashMap could be lost

Object.hash(some, some2);


# this

Can separate local variables from instance variables. this determinas instance variables.
Use this reference when instance and local variables have the same name.


# static

For specified class then be only one static variable.
Initialization is during class loading. Static method does not work on objects. Math.pow(x,a).
Gets memory only once in class are at time class loading.
Refer to common property of all objects, company name for example.
Static methods belongs to class rather than object of class.
Can be invoked without creating an instance of class.
this and super cannot be used in static context.
Why java main method is static?
Because object is not required to call static method if it were non static method, jvm create object first
then call main() method that will lead the problem of extra memory allocation.
Static block is used to initialize the static data member. It is executing before main method at the time of class loading.
Static, variable (class variable), method (class method), block, nested class.
Factories methods - static methods that returns new class instance.


# Enum

Named constants. No need to use equals method. No need to override toString.
Thread safe.


# String

* Immutable and final
* Thread safe - prevent from change cach
* String pool cache (optimization)
* Hash codes - keys in hashCodes are Strings


# Interfaces

* All methods public abstract
* All properties public static final
* Implement interfaces, want to imitate behavior of class
* Use to impose behavior on other classes
* You can implements more than one interface (impose behavior), example implements Comparable interface to extort
  sorting behavior


# Class Object

* Parent class of all classes
* hashCode
* equals


# Abstract class and methods

* Cannot instantiate abstract class
* Are needed during inheritance
* Whant something to be overriden to not forget about it later
* Additional responsibilities added to class


# OOP

* Objects - containers that keep variables functions thematically connected to each others, to use it easier later
* Classes - Frame to build instances of objects
* Objects have, properties, methods
* Constructor - reserve space in memory for object
* Creating an object from a class ins called instantiation


# Serialization

* Abstract class - high level class, by whom inherits
* Data serialization allows to know about all references (extends)
* Serialized object will be read to file. They will acquire some special identification number, object will use this
  number to other objects
* To perform serialization class need to implements Serializable interface
* Serializable marker interface (without method), safety guard to make sure you know what you are doing.
* transient data that we dont want to be serialized
* Fragile data should be marked as transient, or should not implement Serializable


# What is the difference between composition and inheritance ?

Composition refers to defining behavior by member variables a class includes
Inheritance refers to defining behavior by the interfaces or classes that a class inherits from
Composition = "has-a", Inheritance = "is-a"


# How are the Strategy Pattern and Dependency Injection related ?
Each defines behavior by setting member variables of a class


# Reflection

Reflection is a way to invoke methods of objects on the fly at run-time.
Reflection is slow and complicated. Method call via reflection may take 10x longer than usual.
Instantiation an object from a name of a class.
Reflection is the ability at runtime to actually create objects of classes, invoke methods, manipulate metadata
Type introspection is the ability at runtime to explore the type of an object.
Refletion drawbacks: complectit, performance overhead, security consideration, violation of abstraction.
Reflection is good for unit testing jUnit.


# Volatile

* Declaring variable volatile means the value of this variable will never be cached thread locally.
  All reads and writes will go straight to main memory. Access to the variable acts as through it is
  enclosed in a synchronized bock, synchronized on itself.
  Slower than cach, make sure value be read every time.

# Synchronized

* Every objects in Java has a lock associated with it.
  This lock is called the intrinsic lock or monitor. It is possible to specify that only one thread can
  execute a section of code once it has acquired the lock on same object.
  If some other thread currentl holds that lock, the current thread must waits its turn.
  This is achieved using synchronized keyword.
  Using right making a method synchronized can help eliminate thread interference and memory consistency error.
  Making method synchronized is a shortcut to making the entire body of the method as synchronized on "this".
  If we use synchronized we don't need to use volatile keyword.


##########
# Java 8 #
##########

# Lambda
Is a block of code that you can pass to use in future once or more times. Useful
Pass comparision method Arrays.sort
Run task in different thread
Action event example after button clicked

# Functional Interfaces
In Java there are a lot of interfaces that determines the action like Runnable or Comparator.
Lambda expression is compatibile with this interfaces.
You can putlambda expression in all places, when you can put object that implements one abstract method.
Such interfaces are called functional interfaces.

# Streams
Process data in more abstract way, than in case of collections. In case of stream you determine what should be done
not the way it will be executed. Ore processing details live on implementation.
Example xalculate average value of parameters. Your task is to determine the source of data
and parameters, library that use stream optimizes all calculations and process the result.
long counter = word.stream().filter(s->s.length() > 12).count();
3 stream steps. Create stream, determine intermediate operations that modify stream to other form.
End operation that generates result. After taht step stream cannot be used anymore.

# Optional
Optional object Optional<T>pack up object type T. Optional Object is safe alternative to reference to T type,
which can accept object or null value. Use method that returns alternative value if returned value does not exists
or take value if present.
String value = OptionalString.orElse(""); // String or " " if not
String result = OprionalString.orElseThrow(IllegalStateException::new); // Throw exception if no value
ifPresent method accepts function. If optional value exists, is passed to function. Else do nothing.
Optional value is a stream of size zero or one. If value exists function is triggered.


##################
# Big-O Notation #
##################

Complexity and the Big-O notation
Performance is a measured along resource consumption and code consumes variety of resources.
Improving code performance beyond a certain point involves Tradeoffs
Consuming more of one resources can help consume less of another.

Measures of performance
Time - The amount of processing or number of operations code has to perform to accomplish it's objectives.
Space - This is both the memory needed by code to store information at run-time as well as disk space needed by code for persistent storage.
Network - The bandwidth code uses to pass information to clients or other machines.

Performance indicates how much of these resources the code uses. Code is also more performant when
it uses the resources we have in plenty rather that those we lack.

Complexity
Complecity is a measure of how resource requirements change as the size of the problem gets larger.
Affects performance. The higher the complexity the problem the lower the performance.

Time required by code to run depends on the basic operations it performs.
Arithmetic operations read, assignment write. How performance changes based on input size.
Focus on the worst case performance.
Code uses time, space and network resource. The amount of resource used determines code's performance.
Complecity is a measure of performance.

Big O Notation allows us express complexity as a measure of input size. This express the complexity of an algorithm.
A algorithm which complexity does not change with input size is O(1), is said to have constant time complexity.
The Complexity of an algorithm is O(N) is the time taken by the algorithm increases linearly when N increases.
The Complexity of an algorithm is O(N^2) if the time taken by the algorithm increases quadratically when N increases.
for (int i = 1; i < n;) {
    i = i * 2;
}
The complexity of this operation is O(log(N))

Lists and Sets |  get  | add   | remove | contains
---------------+-------+-------+--------+---------
ArrayList      | O(1)  |  O(1) |  O(n)  |  O(n)
LinkedList     | O(n)  |  O(1) |  O(1)  |  O(n)
HashSet        | O(1)  |  O(1) |  O(1)  |  O(1)
LinkedHashSet  | O(1)  |  O(1) |  O(1)  |  O(1)
TreeSet        |O(logN)|O(logN)| O(logN)| O(logN)
---------------+-------+-------+--------+---------
Maps
---------------+-------+-------+--------+---------
HashMap        | O(1)  |  O(1) |  O(1)  |  O(1)
LinkedHashMap  | O(1)  |  O(1) |  O(1)  |  O(1)
TreeMap        |O(logN)|O(logN)| O(logN)| O(logN)


Queue           | offer  | peek | pull   | size |
----------------+--------+------+--------+------+
PrioritityQueue | O(logN)| O(1) | O(logN)| O(1) |

Sorting algorithms | Time Complexity | Space Complexity |
-------------------+-----------------+------------------+
MergeSort          |     O(NlogN)    |       O(n)       |
TreeSort           |     O(NlogN)    |       O(n)       |

#########################
# Garbage Collection GC #
#########################

* Java provides automatic memory management through a program called Garbage Collector. "Remove object that are not use"
* live object = reachable (referenced by someone else)
* dead object = unreachable (unreferenced)
* Objects are alocated in the "heap" of java memory
* static members, class definition are stored in "method area" Permgen/Metaspace
* Garbage Collection is carried out by a daemon hread called "Garbage Collector"
* Force GC to happened System.gc (no guaranteed)
* Wen failed to alocated bcause of full heap. Error message java.lang.OutOfMemoryError

* Gargage Collector involves
    - Mark : go through all program structure, mark reachable objects as live
    - Delete/Sweep : Delete unreachable objects
    - Compacting : Compact memory by moving around objects

* Typed of Garbage Collector
    - Serial Collector : Runs on single thread, useful in basic applications
    - Concurrent Collector : GC execute as application runs, not wait the old generation to full stop the world
      execute only during mark/re-mark phase
    - Parallel Collector : Uses multiple CPUs to perform GC. Multiple threads doing mark/sweep. Does not start until
      heap is full/near-full. "Stop the world" when runs.

* Use Concurrent collector, when there is more memory, high number of CPUs, short pauses required
* Use paraller collector, when there is less memory, lesser number of CPUs, high throughput required, pauses are OK

java -XX:+UseSerialGC
java -XX:+UseParallelGC
java -XX:+UseConcMarkSweepGC


###############
# Concurrency #
###############
* fail-safe do not throw ConcurrentModificationException
* fail-fast throw ConcurrentModificationException
* volatile - value read always from main memory no cache
* synchronized - acquire intrinsic lock on object. Only one object can execute this part of code.
* join() - wait until other thread finish executng


# Process and threads

* In concurrent programming two units of executio process and treads.
* Processing time for a single core is shared among processes and threads, time slicing

* Process : Has a self contained execution environment. Private set of runtime resources.
  Each process has its own memory space. Process can communicate with each others IPC.

* Threads : Lightweight process. Creating a new thread requires fewer resources than creating a new process.
  Exists within a process. Every process has at least one thread.

* join() : method wait until thread to finish

* threads prioritity : importance of a thread to the sheduler. Lower prioritity thread tend to run less often.
  setPrioritity(), getPrioritity(). MAX_PRIORITITY, NORM_PRIORITITY, MIN_PRIORITITY

* yield() : this static method is essentially used to notify the system thet the current thread is willing to
  give up CPU for a while, but sheduler can immediately pick them back. Is put back into the ready queue of the processor,
  and waits for it next turn.


# Start Thread

* Extends Thread - override run() method

* Implements Runnable - override run() method, pas Runnable object to Thread class constructor. Call start method
  on thread object.

* Executor Service - dynamically reuse thread. Check if threads are already working.
  - Executors.newCachedThreadPool() return an executor service that can dynamically reuse threas.
    Before starting a job, it going to check wether there are any threads that finished the job if so reuse them.
    If no create new one, good for processor effective solution
  - Executors.newSingleThreadPool() uses single thread for the job.
  - Executors.newFixedThreadPool() maximize the number of threads. If all the thread are busy we have to wait
    for one to terminate.

  - executorService.execute(Runable)
  - executorService.execute(Callable or Runnable)


# Concurrent Collections

    # ConcurrentHashMap
    * Full concurrency during retreival
    * Reads can happen fast, while writes require lock
    * Whole table is not locked only segment is locked
    * Iterations do not throw concurrent modification exception
    * Null key not allowed
    * Operations are atomic

    # BlockingQueue
    * Interface that represents a queue that is thread safe. put(), take()

    # DelayQueue
    * Like BlockingQueue that implements Delay interface. Cannot put null into it.

    # PrioritityBlockingQueue
    * Iplements Comparable interface. Determine what will be the order of a Queue.


# Threads complications

* Thread interference and memory consistency errors
    - If two thread access the same variable, it is possible for them to get in each others way
      For example tow threads incremanting the same variable at the same time.
      To fic this make sure that section of code is only accessed by one thread at a time, by using synchronized keyword for example.
      But this slows down performance, and can lead to thread contention issues (starvation, livelock, deadlock)

* Thread Contention
    - Deadlock : two thread each is blocked by a lock held by the other
    - Livelock : two thread's don't deadlock, but keep blocking on locks held by each other, neither can progress
    - Starvation : Same thread keep acquiring locks greadly. And cause other threads to be unable to get anything done.


# Semaphores

* Variables that are used to controlling access to common resources, important in OS.
  is a record of how many units of particular resource are available.
  Semaphores track how many resources are free, it does not keep track of which of the resources are free.
  Metexes are binary semaphores. Mutex has a concept of an owner. Only process that locked a mutex is supposed to unlck it.
  Methods acquire() if permit is available take it, release() add a permit.


# Callable and Future

* Returns something from a thread implements Callable instead of Runnable.


# Thread States

* Runnable - create a new thread and call start method
* Blocked - enter synchronized block, lock
* Waiting - after wait()
* Terminated - run method is over


# Concurrent Libraries

    - CountDownLatch : Used to synchronize one ore more tasks by forcing them to wait for completion of a set of operatios
      being performed by other tasks. Give initial count to count down latch object and task that calls await() on that
      oject will block until count reaches zero. The count cannot be reset. Typically use is to divide a problem into "n"
      independetly solveable tasks and create a CountDownLatch with value of "n".
      When each task is finished it calls countDown on Latch. Task waiting to solve call await() on the Latch to hold
      themselves back until it is completed.

    - CyclicBarrier : Used in situation where you want to create a group of tasks to perform work in parallerl plus wait
      until they are still finished before moving on to the next step, like join or countDownLatch.
      Can be reused.


## From Java 8 Book ##

# Concurrent Programming
Runnable describes task that might be executed asynchronously.
Executor plans execute runnable instance.
Callable tasks that return results or throw exception.
Results without synchronization are unpredctable.
Beter use thread safe data structures than use locks.
ConcurrentHashMap is thread safe array allows to updates elements using atomic operations.
To interrupt task set interrupt flag or throw InterruptedException.

Thread is mechanism that allow to execute sequence of instruction, these instructions are delivered by OS.
Couple of threads work in parallel using multiple porcessors of different time slice of the same processor.

Executor executes a task by choosing threads that might be executed with.
Runnable task = () -> {};
Executor exec = Executors...;
exec.execute(task);

Factory method Executor class
Executors.newCachedThreadPool() - each task execute in safe thread, couple of small tasks
Executors.newFixedThreadPool(thread_num); - good for grater amount of tasks
To acquire number of thread based on number of processors.
int processors = Runtime.getRuntime().availableProcessors();

Objects Future and Executor
Callable - Method call() oposite to method run() Runnable interface returns value or throw an Exceptions.
To execute callable there is a need for ExecutorService instance.
ExecutorService exec = ExecutorService.newFixedThreadPool(2);
Callable<V> call = ...;
Future<V> result = exec.submit(call);
Future is an object that represents a calculations, which results will be accessible in a future.

Thread safety
RAM memory are slow, couple of time slower then modern processors. Processor try to collect needed data
in registers or cache memory on main board, and lastly make changes in main memory.
This cache memory is key factor for performance optimization.
Thread Visibility
- final value is visible after initialization
- initial value of static variable is visible after static initialization
- changes variale with volatile keyword are visible
- changes after release a lock are visible for all that acquire this lock.
Volatile keyword - compilator generates needed instructions to make sure that all changes that being applien in one task are
reachable in another.

Chasing
Are problems always when shared variables are modified. Locks to critical section make atomic.

Strategy of safety concurrency
- Avoid schare data between tasks. One task z1, second task z2, z3 = z1 + z2
- Use immutable objects
- Locks allows only one task access to data at a time. Use data ctructures and algorithms from java libraries.

Un modifiable classes
Class in immutable if instance after creation cannot change.
Implement immutable class
- variable with final modificator
- non method can modufy data
- do not allow to leack modification
- Do not allow to this refernece pass outside constructor

Concurrent Algorithms
* Parallel Strams
Long results = coll.parallelStream().filter(s->s.startsWith('a')).count();
ParallelStream method returns parallel stream. Stream is parted on segments.
Filtering and counting is executed for each segments and results are joined together without your further interactions.
* Parralel operations on arrays
Arrays operations part array on segments, parallelly process them and join results.
Arrays.parrarelSetAll(), parallelSort()
Process array into a stream, long sum = IntStream.of(value).parallel().sum();

Thread safe data structures
ConcurrentHashMap
Map on which operations are thread safe. Can support large number of parallel read and some number of parallel reads.
To actualiza data compute method. This method is Atomic, no other thread can modify map content while executing operation.
BlockingQueues
Is one of the most commonly used tool for synchronized work. One task put element into the queue, while take task
take element fro a queue. Allows to safety pass tasks from one task to another.
LinkedBlockingQueue, ArrayBlockingQueue.
ConcurrentSkipListMap - compare keys.
ConcurrentSkipListSet
CopyOnWriteArrayList, CopyOnWriteArraySet - are thread safe thanks the fact that all methods that modify collection
make copy used array. Good in situation when number of threads go through queue is larger than number of thread that modify queue.

Atomic Values
AtomicLong nextNumber = new AtomicLong();
long id = nextWord.incrementAndGet();
Atomic operation, load data, modify data and save data cannot be interrupted in between.

###################
# Design Patterns #
###################

* Design Patterns are canonical solutions to recuring problems
* Creational Patterns "How should object be created"
    - Factory, AbstractFactory, Singleton, Builder, Prototype, Dependency Injection
* Behavioral Patterns "How should object behave and interact with each other"
    - Strategy, Template, Iterator, Command, Chain of Responsibility, Memento, Visitor, State, Mediator, Observer
* Structural Patterns "How should classes behave and interact with each other"
    - Decorator, Adapter, Facade, Composite, Flyweight, Bridge, Proxy
* Concurrency Pattern "How should specific situation be handled in multithreading"
    - Double checked locking
* Model View Controller "Architectural pattern"

* Libraries and Frameworks are both code written by others that we can use.
* Design Patterns are proven ideas for solving common problems.
* Code usually calls libraries and is often called by frameworks, but is stractured using Design Patterns


# Creational

* How objects are constructed
* Decouple the construction of an action from its use
* Hide implementation of an object only reveal its interface
* Defer instantiation until run time
* Families of related objects that must be used together
* Allow creation of finite number of instances


# Behavioral

* How do objects behave and interact with each other
* How logical unit (classes) as whole interacts with the outside world
* Iterator pattern - here logical unit includes 1 class Iterator class. This pattern governs how the
    is used by the client (the outside world)


# Structural

* How classes within the logical unit interacts with each other
* MVC pattern - logical unit includes 3 classes model, view, controller
    The pattern governs how the Model, View, Controller interact with each other
    If the interaction etween the M, V, C were change, the UI would not look or behave any different !


# Design Principle #1 : Relay on Interfaces, not implementation

"Program to an interface not implementation" decorator, iterator, adapter

Interface is a surface that a unit offers to outside world.
That unit could be a single class, or even be a collection of classes.
The implementation is a guts of that unit.
Never get assumption about content of any unit.
ArrayList<String> list = new ArrayList<>(), wrong
List<String> list = new ArrayList<>(), correct


# Design Principle #2 : The Open / Close Principle

"Classes should be open for extension but closed for modfication"

Once you have written a class, it's done. Never add enything to it after that.
No new member variables, no new methods, no new interfaces implemented, No modification.
But other code should be able to use your class in new ways, New applications via extension.

* Inheritance, template pattern
    - If you structure your code into abstract base class, other classes can find
      new way to use it via Inheritance

* Delegation, observer, MVC, Chain of Responsibility
    - If you fire events and expose properties, other code can listen in, and use your code via Delegation

* Composition, strategy pattern
    - If you take in member variale to determine behavior, you allow extension via Composition


# Design Principle #3 : Principle of Least Knowledge

"Only talk to friends, don't talk to strangers"

Only make method calls to friends.
friends - object passed in as parameter to methods of your classes. Object created insde your class.
Code should never include multiple '.' operators in the same function call.
int friendNumber = media.getRelatives().getFriend(), not OK
int firndNumber = media.getFriend(), OK
But this rule is not always a case.
Summarized, each unit should have only limited knowledge about other units. Each unit should only tolk to its friend.


# Design Principle #4 : Dependency Injection

"Depend on abstraction never on details"
Used technique to set member variables of objects on the fly.


# Design Principle #5 : Hollywood Principle

"Don't call us we will call you"
Class notifies other class of changes when they occurs via events or messages.
Idea high-level component calling low-level is used components in frameworks.


# MVC Paradigm

Model View Controller is an architectural pattern. In Java API Swing.
Basic idea of MVC is to separate data from its representation, separating data from its manipulation,
allowing different simultaneous representations of the same data.
MediaPlayer Example. Controller a slider to adjust volume in a media player app. Model the mp4 file of a movie
to be played in a media player app. View the area of the media-player app that actually displays video.
User sees the model through a view, and manipulates it via the controller.


# What is a basic point of observer pattern

An object announces updates to its value, and other objects can read to these updates.


# When a publisher fires an update, how do subscriber bacome aware of it.

The publisher has a list of listeners, and Java cycles through them and Executes the callback function they had specified.


# How are properties and bindings different from eah other.

Properties are ONE:ONE, bindings are ONE:MANY


# How Observer and MVC related

The View act as publisher, controller as subscriber




















