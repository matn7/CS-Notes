# ClassCastException

- When references to objects points to objects different classes
- When argument is wrong type, method compareTo should throw ClassCastException
- No explicit casting
- Try add wrong data type to collection or array
- SerialVersionUID


# Constructor Chaining

Call in the same class this()
Call from parent class super()
Use to execute more tasks in one constructor
Improve readability of code

public Temporary(int x, int y) {
    this(5);
    System.out.print(" " + x * y + " ");
}
public Temporary(int x) {
    this();
    System.out.print(" " + x + " ");
}
public Temporary() {
    System.out.print(" Default ");
}
-> Default  5  782


# Overloading

Compile time polymorphism
Use the same method name but with different arguments
static binding binds private, final, static method, fields, class, variables

# Overriding

Runtime polymorphism
The same method name with exactly the same arguments
dynamic binding
We cannot override private methods in Java as if we declare any variable, method as private that variable or method
will be visited for that class only and also if we declare any method as private than they are bounded with class at compile
time not in runtime so we can't reference those method using any object

You cannot override static method in Java becouse method overriding is based upon dynamic binding at runtime
and static method are bounded using static binding at compile time


# final

Value of member variable cannot be changed
Object reference cannot be changed
Class cannot be inherited
Method cannot be overriden


# finally

Try, catch block. Stuff in finally always be executed, even when in try return statement
Finally does't execute in cases like
program crash before go to this block or System.exit(0) in try


# finalize

JVM call this method when GC is about to be called


# == vs equals

== check whether object are the same (point to the same place in memory, the same object)
.equals() when compare content of objects


# Class Loaders

Bootstrap Class Loader
Extension Class Loader
System Class Loader


# SerialVersionUID

Mark added to class to during deserialization, reconstruct proper class (unique identifier).
Useful when there is some complex class hierarchies parent class, child class.


# hashCode, equals

You must override hashcode in every class that overrides equals. Failure to do so affect working with hash based
collections like HashMap, HashSet
In Map objects are stored as key and value. put(key,value) method is used to store objects in HashMap at this time
hashCode() method is used to calculate the hash code of key object and both kay and value object is stored
as map.entry, if two keys object have some hash code then only one value object is stored in the same bucket location but
as a linked list value is stored and if hash code is different then another bucket location is created.
While retrieving get(key) method is used at this time hash code of key object is calculated and then equals() method
is called to compare value object.


# equals

Check whether one object can be equal to another.
Equals method implemented in Object class, check whether two references to object are identical.
Override equal method if you want to check equality based on state of object.
Two object are equals when they have the same value.

Checks that we need to perform.
    // Check whether objects are identical, very fast
    if (this == otherObject) return true;
    // False if parameter is null
    if (otherObject == null) return false;
    // Check whether otherObject is the same instance as this), use getClass or instanceof
    if (getClass() != otherObject.getClass()) return false;
    // Check values
    return Objects.equal(some, other.some) && ...;


# hashCode

Hash is integer number that identify an object.
If x and y are different objects, x.hashCode and y.hashCode should also be different (but not always are).
for (int i = 0; i < str.length(); i++) {
    hash = 31 * hash + chartAt(i)
}

HashCode must be compatible.
if x.equals(y) return true, x.hashCode == y.hashCode.
If you change equals method you have to change hashCode also. Failure to do so results in objects put in hash based
data structures HasSet, HashMap could be lost.
Object.hash(some, some2);


# this

Can separate local variables from instance variables.
'this' determines instance variables.
Use this reference when instance and local variables have the same name.


# static

For specified class can be only one static variable.
Initialization is during class loading. Static method does not work on objects. Math.pow(x,a)
Gets memory only once in class are at time class loading.
Refer to common property of all objects, company name for example.
Static methods belongs to class rather than object of class.
Can be invoked without creating an instance of class.
'this' and 'super' cannot be used in static context.

Why java main method is static?
Because object is not required to call static method if it were non static method, jvm create object first
then call main() method that will lead the problem of extra memory allocation.

Static block is used to initialize the static data member. It is executing before main method at the time of class loading.
Static, variable (class variable), method (class method), block, nested class.
Factories methods - static methods that returns new class instance.

You cannot override static method in Java because they are resolved at compile time rather than runtime


# Enum

Sometimes you need to define connected constants like
public static final int MONDAY = 0

You can do this using enum
enum Weekday {MON, TUE,.. };
Now weekday is datatype with values Weekday.MON

public Enum Size { SMALL, MEDIUM, LARGE; }
Named constants. No need to use equals method. No need to override toString.
Thread safe.
Enum is subclass class of Enum class, which contains toString, valueOf and compareTo method
Compare element using ==
Methods : valueOf, ordinal
Enum constructors are always private.
Variables Enum type can contains static variables
static import now can use SMALL instead of Size.SMALL


# String

Immutable and final
Thread safe - prevent from change cache
String pool cache (optimization)
Hash codes - keys in hashCodes are Strings


# Interfaces

All methods public abstract
All properties public static final

Implement interfaces, want to imitate behavior of class
Use to impose behavior on other classes

You can implements more than one interface (impose behavior), example implements Comparable interface (strategy pattern)
to extort sorting behavior.

You cannot put instance variables. Interface determines behavior not state of object.
You can provide default implementation of interface. Mark such method with default modifier
public interface IntSequence {
    default boolean hasNext() {return true; }
}

Keyword super allows to call super type methods
Comparable interface when class want to allow sort their elements Comparable.
Callback - code fragment is call as a result on user response
Interface is used heavily n API to define contract of a class.
You cannot create non abstract method in interface. All methods are for default abstract.


# Class Object

Parent class of all classes
hashCode
equals
toString - representation of object as String by default class name pls hash
clone


# Abstract class and methods

Cannot instantiate abstract class
Are needed during inheritance
Want something to be overriden to not forget about it later
Additional responsibilities added to class


# OOP

Objects - containers that keep variables functions thematically connected to each others, to use it easier later
Classes - frame to build instances of objects
Objects have, properties, methods
Constructor - reserve space in memory for object
Creating an object from a class is called instantiation

Constructor references
Are counterpart to method references.
Employee::new
int[]::new === n->new int[n]

Local class is not declared as public or private as it isn't available outside of method

Abstract method does not have implementation, abstract class can not have instantiation.
Class can define methods without implementation forcing subclasses to implement them.
Such method and class that contain it are called abstract.
Abstract classes can have instance variables or constructors.
Cannot instantiate abstract class
Abstract calss is used to provide default implementation with something left to customize.

Encapsulation - use of objects implemented by someone else, use their methods without know what sits inside

Instance variable are in default initialized
Local variables need to be explicitly initialized

If part can exists without whole then relationship between two class is known as aggregation
If part cannot exists without whole the relationship between two class is known as composition


# Serialization

Abstract class - high level class, by whom inherits
Data serialization allows to know about all references (extends)
Serialized object will be read to file. They will acquire some special identification number, object will use this
number to other objects
To perform serialization class need to implements Serializable interface
Serializable marker interface (without method), safety guard to make sure you know what you are doing
transient data that we dont want to be serialized
Fragile data should be marked as transient, or should not implement Serializable

Serialization is a machanism to transform in collection of bytes, which can be then deliver to other place
save on disk, and reconstruct objects based on this collection of bytes.
Deliver object from one VM to another. To make object serializable that means can transform to bytes states
it has to be an instance of Serializable interface. It is an marker interface without methods.
All object must be serializable.
Serializable mechanism supports version mechanism serialVersionUID = 1L;
is used to enhanced state, what would happen when class would change
Static variables are no serialized only istance variables are serialized


# Different between Serializable and Externalizable

Serializable is marker interface with no method defined
Use default serialization process which can be very slow for some application
Externalizable interface has two methods readExternal() and writeExternal() which allows you to control the
serialization process


# What is the difference between composition and inheritance ?

Composition refers to defining behavior by member variables a class includes
Inheritance refers to defining behavior by the interfaces or classes that a class inherits from
Composition = "has-a", Inheritance = "is-a"


# How are the Strategy Pattern and Dependency Injection related ?

Each defines behavior by setting member variables of a class


# Reflection

Reflection is a way to invoke methods of objects on the fly at run-time
Reflection is slow and complicated. Method call via reflection may take 10x longer than usual
Instantiation an object from a name of a class
Reflection is the ability at runtime to actually create objects of classes, invoke methods, manipulate metadata

Type introspection is the ability at runtime to explore the type of an object.

Reflection drawbacks: complexity, performance overhead, security consideration, violation of abstraction

Reflection is good for unit testing jUnit


# Volatile

Declaring variable volatile means the value of this variable will never be cached thread locally
All reads and writes will go straight to main memory. Access to the variable acts as through it is
enclosed in a synchronized bock, synchronized on itself
Slower than cache, make sure value be read every time

Happens-before relationship means any writes happens before any read in volatile variable
Every thread reads its value from main memory and don't used cached value available in every thread stack
Volatile variable prevents compiler from doing reordering which can compromise synchronization

Only applicable to field or properties of class.
You cannot use volatile keyword during class or method declaration in Java


# Synchronized

Every objects in Java has a lock associated with it
This lock is called the intrinsic lock or monitor. It is possible to specify that only one thread can
execute a section of code once it has acquired the lock on same object
If some other thread currently holds that lock, the current thread must waits its turn
This is achieved using synchronized keyword

Using right making a method synchronized can help eliminate thread interference and memory consistency error
Making method synchronized is a shortcut to making the entire body of the method as synchronized on "this"
If we use synchronized we don't need to use volatile keyword


# Enumerator and Iterator differences

Iterator allows you to remove elements from collection. Methods for iterator hasNext(), next()
Iterator does not allow other thread to modify the collection object while some thread is iterating over it and throws
ConcurrentModificationException

Enumerator hasMoreElements(). For Collections read only


# Checked and Unchecked Exceptions

Checked Exceptions ensures that handling of exception is provided and its verified by compiler also
For throwing unchecked exception no special provision is needed.


# What is load factor of HashMap

HashMap performance depends on two things initial capacity and load factor.
Whenever create HashMap initial capacity number of buckets is created initially and load factor is criteria
to decide when we have to increase the size of HashMap when its about to get full


# Why wait and notify is declared in Object class instead Thread?

Both are communication mechanism between two threads in Java
Object class makes them available for every object if this mechanism is not available via any Java keyword like
synchronized
Locks are available on per Object basis, which is another reason wait and notify is declared in Object class
rather than Thread class


# Why wait and notify called from synchronized method in Java?

To avoid:
- IllegalMonitorStateException which will occur if we don't call wait(), notify() or notifyAll() method
from synchronized context
- Any potential race condition between wait and notify method in Java


# What will happen if we put a key object in a HashMap which is already there?

It will replace the old mapping because HashMap doesn't allow duplicate keys
The same key will result in the same hashcode and will end up at the same position in the bucket
Each bucket contains a linked list of Map.Entry object, which contains both Key and Value
Now Java will take the Key object from each entry and compare with this new key using equals() method, if
that return true then value object in that entry will be replaced by new value


###############
# Collections #
###############

Collection interface provides methods for all collections except Map which are provided by Map interfaces

Thread safe data structures
In such collections iterators presents elements which exists on the beginning of iteration but can reflect some lub
all modifications that beeing processed after their creation. Such iterator does not throw ConcurrentModificationException.

# LIST

List is sequential collection in which every element has index in form of integral number
List interface has mathods which allow to access to n th element of List. To do so Class should implement RandomAccess
interface. It is a marker interface which does not have any methods.
For instance ArrayList implements List and RandomAccess, but LinkedList only List interface.
RandomAccess means random search if you know the index, LinkedList only allows sequential search.
Adding and removing elements from middle of LinkedList is fast compared to ArrayList, because it only
require to modify links and no other elements are rearranged.


# SET

Sets are to optimize strength test. Java has implementation of HashSet and TreeSet


# MAP

In Map you can choose between HashMap or TreeMap. LinkedHashMap maintains insertion order

ConcurrentHasMap does not allow null values for keys or values
LinkedHashMap maintains insertion order and process elements based on this order

# ConcurrentHashMap
Methods in atomic ways sets or replace elements if it is the same at a point of time.
There are couple of mass operations to search, modify or look for ConcurrentHashMap.
search, reduce, forEach.

ConcurrentHashMap vs HashTable vs SynchronizedMap
All are thread safe.
HashTable uses synchronized method to achieve thread-safety. Quite slow if number of thread increases.
SynchronizedMap not very different from HasTable similar performance in concurrent Java program.
You can create synchronized Map version by using Collections.synchronizedMap().
ConcurrentHashMap is specially designed for concurrent use i.e. more than one thread.
By default it simultaneously allows 16 hreads to read and write from Map without any external synchronization.
It is very scallable beaause of stripped locking technique used i the internal implementation of ConcurrentHashMap class.
Unilike HashTable and Synchronized Map, it never locks whole Map, instead, it divides the Map into segments and locking is done on those.
It perform better if number of reader are greater than the numberof writer threads.

In multithreading Java application synchronized collection classes like Hashtable and Vector quickly becomes
the bottleneck, to address that Java 5 introduced some concurrent collections.

ConcurrentHashMap and CopyOnWriteArrayList implementations provide much higher concurrency while preserving
thread safety

BlockingQueue
pool, peek methods return null to sygnalize failure. In that reason insert null vales to them is incorrect
LinkedBlockingQueue
ArrayBlockingQueue
Other Thread Safe Data Structures
ConcurrentSkipListMap
ConcurrentSkipListSet
CopyOnWriteArrayList
CopyOnWriteArraySet

HashMap implements Map interface there by supporting key values pairs.

TreeMap is similar to HashMap except that it stores keys in sorted order. It implements NavigableMap interface and
SortedMap interfaces along with tha Map interface

PrioritityQueue
Implements Queue interface.
-offer() adding an element to prioritity queue
-peek() get the element with highest prioritity

What is the difference between synchronized and Concurrent Collections
Synchronized collections are implemented using synchronized mehods and synchronized blocks. Only one Thread
can executing any of the synchronized code at given point in time. This places severe restrictions on the concurrency
of thread - there by affecting performance of the application. All the pre Java 5 synchronized collections
HashTable & Vector use this approach
Post Java 5 collections using new approach to synchronization are available in Java.
These are concurrent collections
--------------------------------+--------------------------------
SYNCHRONIZED                    | CONCURRENT
--------------------------------+--------------------------------
Use synchronized                | New approach to thread safety
methods and blocks              |   - Copy on Write
                                |   - Compare and Swap
                                |   - Lock and unlock
--------------------------------+--------------------------------
Vector, HashTable               | CopyOnWriteArrayList
                                | ConcurrentLinkedQueue
                                | ConcurrentHashMap
--------------------------------+--------------------------------
Only one thread Executing       | New approaches allow more
any of the synchronized         | concurrency in specific
code                            | context
--------------------------------+--------------------------------
fail fast iterators             | fails safe iterators
throw                           | don't throw
ConcurrentModificationException | ConcurrentModificationException
--------------------------------+--------------------------------

Post Java 5 collections using new approach to synchronization are available in Java.
These are called concurrent collections. Examples of new approaches are
- Copy on Write
- Compare and Swap
- Lock and Unlock
New approaches to concurrency provide better performance in specific context

Copy on Write
All collections are sorted in immutable array. A new array is created if there is anymodification to the collection
Read operations are not synchronized. Writes operations are synchronized.
Copy on Write scenario is used where reads greatly out number writes on a collection
CopyOnWriteArrayList and CopyOnWriteArraySet are implementations of this approach
Copy on Write collections are typically used in subject - observer scenario, where the observed very
rarely change. Most frequent operations would be iteration around the observers and notifying them.

What is Compare and Swap approach
In compare and swap approach instead of synchronizing entire method, the value of member variable before
calculation is cached. After the calculation the cache value is compared with the current value of member variable.
If the value is not modfied the calculated result is stored into the member variable.
If another thread has modified the value, then the calculation can be performed again, or skipped as the need might be.
ConcurrentLinkedQueue uses this approach.

What is a Lock? How is it different from using synchronzed approach?
When 10 methods are declared as synchronized, only any of them is executed by any of the threas at any point in time.
This has severe performance impact.
Another new approach introduced in Java 5 is to use lock and unlock methods. Lock an unlock methods are used
to divide methods into different blocks and help enchance concurrency.
The 10 methods can be divided into different blocks which can be synchronized on different variables.

What is initial capacity of a Java Collection?
An instance of HashMap has two parameters that affect its performance initial capacity and load factor.
The capacity is the number of buckets in the hash table, and the initial capacity is the capacity at the time the
hash table is created. The load factor a measure of how full the hash table is allowed to get before its capacity automatically increased.
When the number of entries in the hash table exceeds the product of load factor and the current capacity, the hash
table is rehashed (internal structure rebuild). So the hash table has approximetely twice the number of buckets.
As a general rule the default load factor .75 offers a good tradeoff between time and space cost.
Higher value decrease space overhead but increase the lookup cost (put and get operations).

What is a different between fail safe and fail fast
Fail fast iterators throw ConcurrentModificationException if there is a modification to the underlying collection is modified.
This was the default behavior of the synchronized collections of pre Java 5
Fail safe iterators do not throw ConcurrentModificationException even when there are changes in the collection.
This is the default behavior of the concurrent collections, introduced since Java 5

What are atomic operations in Java?
In programming an atomic action s one that effectively happens all at once. An atomic action cannot stop in the middle.
It either happens completely or it doesn't happen at all. No side effect of an atomic action are visible until the action is completed.
Even small operation like i++ id not thread sfe. Operation involves three steps:
- Read the value which is currently stored in i
- Add one to it (atomic operation)
- Store it in i
In multithreaded environment there can be unexpected results. For example if thread1 is reading the value
and immediately after that thread2 store the value.
To prevent these, Java provides atomic operations. Atomic operations are performed as a single unit
without interference from other threads ensuring data consistency.
A good example is AtomicInteger. To implement a value of AtomicInteger we use the incrementAndGet() method Java ensures this operation is Atomic.

What is the BlockedQueue in Java?
BlockedQueue interface is introdced in Java specifically to address specific needs of some Producer Consumer scenarios.
BlockedQueue allows the consumer to wait (for a specific time of infinitely) for an element to become available.

HashMap and HashTable differences
HashMap is not synchronized. Faster than HashTable. Allows null keys.
HashTable is synchronized. Slower than HashMap. Does not allow null keys.

TreeSet and TreeMap differences
TreeSet and TreeMap are both sorted. TreeSet is a Set data structure so it does not allow duplicates.
TreeMap is an implementation of Map.
TreeSet is implemented via TreeMap much like how HashSet is implemented using HashMap.


##########
# Java 8 #
##########

# Lambda
Is a block of code that you can pass to use in future once or more times. Useful
Pass comparision method Arrays.sort
Run task in different thread
Action event example after button clicked

# Functional Interfaces
In Java there are a lot of interfaces that determines the action like Runnable or Comparator.
Lambda expression is compatibile with this interfaces.
You can putlambda expression in all places, when you can put object that implements one abstract method.
Such interfaces are called functional interfaces.

# Streams
Process data in more abstract way, than in case of collections. In case of stream you determine what should be done
not the way it will be executed. Ore processing details live on implementation.
Example xalculate average value of parameters. Your task is to determine the source of data
and parameters, library that use stream optimizes all calculations and process the result.
long counter = word.stream().filter(s->s.length() > 12).count();
3 stream steps. Create stream, determine intermediate operations that modify stream to other form.
End operation that generates result. After taht step stream cannot be used anymore.

Streams allow efficient parallel process
You can create strams from Collection, Generators or Iterators
Use filter to choose elements and map to process them
Other operation to process stream : limit, distinct, sorted
To get result from stream use reduce operator like : count, max, min, findFirst, findLast, some of them returns Optional vale
Optional type is a safe way to work with null values. To use them use methods ifPresent, orElse
You can collect stream results in Collections, Arrays, Strings or Maps
GroupyingBy and partitioningBy From Collector class allows to separate stream on group and determine result for each of these groups
Special streams for primitive typed like : int, long, double
Parallel Streams automizes parallel operations on streams

Streams vs Collections
Streams does not store elements. They can be stored in processing by stream collection or generated on demand
Streams operation does not modify source data. For instance filter does not delete elements from stream but returns new one
Sreams operations are lazy. They process is delay until the results are needed.

Stream workflow
Create stream
Determine intermediate operations which process stream to different form, this process might require couple of steps (filter)
Process end operation which generates the result. After this step stream can no longer be used

Map method is analogous to map interface from stream. Optional value is a stream on size ero or one.
filterMap method from stream interface. Is used to join two methods.

ParallelStreams
Stream.of(arrays).parallel()
Map<Integer, Long> word = words.parallelStream().filter(s->s.length() < 12).collect(groupingBy(String::length));

Streams are introduced in Java . In combination with Lambda expression, they attempt to bring some of the
important functional programming concepts to Java.
A stream is a seqence of elements supporting sequential nd parallel aggregate operations.
Consider the flow:
- Creating an array as stream
- Use lambda expression to create a filter
- Use map function to invoke a String function
- Use sorted function to sort array
- Print the array using forEach
Arrays.stream(new String[]{"Ram", "Tam", "Tam"})
    .filter(s->s.startsWith("Ta"))
    .map(String::toLowerCase_
    .sorted()
    .forEach(System.out::println);
In general any use of streams involves.
-source - Creating or use existing stream
-Intermediate Operations - returns new stream
-Terminal operation - consume the stream print.
Intermediate Oparations are of two parts
-Stateful - elements need to be compared against eah others (sort)
-Stateless - no need for comparing with other element (map, filter)


# Optional
Optional object Optional<T>pack up object type T. Optional Object is safe alternative to reference to T type,
which can accept object or null value. Use method that returns alternative value if returned value does not exists
or take value if present.
String value = OptionalString.orElse(""); // String or " " if not
String result = OprionalString.orElseThrow(IllegalStateException::new); // Throw exception if no value
ifPresent method accepts function. If optional value exists, is passed to function. Else do nothing.
Optional value is a stream of size zero or one. If value exists function is triggered.


# Predicate<T>
Function that return logical value.
Predicate.isEqual(a) is counterpart of a::equals, but works correctly even with null values.
Methods and, or, negate to join predicates
Predicate.isEqual(b) === x->b.equal(x)


# Functional Interface
Compilator checks whether marked interface is with one abstract method
Generated javadoc with info that this is an functional interface


##################
# Big-O Notation #
##################

Complexity and the Big-O notation
Performance is a measured along resource consumption and code consumes variety of resources.
Improving code performance beyond a certain point involves Tradeoffs
Consuming more of one resources can help consume less of another.

Measures of performance
Time - The amount of processing or number of operations code has to perform to accomplish it's objectives.
Space - This is both the memory needed by code to store information at run-time as well as disk space needed by code for persistent storage.
Network - The bandwidth code uses to pass information to clients or other machines.

Performance indicates how much of these resources the code uses. Code is also more performant when
it uses the resources we have in plenty rather that those we lack.

Complexity
Complecity is a measure of how resource requirements change as the size of the problem gets larger.
Affects performance. The higher the complexity the problem the lower the performance.

Time required by code to run depends on the basic operations it performs.
Arithmetic operations read, assignment write. How performance changes based on input size.
Focus on the worst case performance.
Code uses time, space and network resource. The amount of resource used determines code's performance.
Complecity is a measure of performance.

Big O Notation allows us express complexity as a measure of input size. This express the complexity of an algorithm.
A algorithm which complexity does not change with input size is O(1), is said to have constant time complexity.
The Complexity of an algorithm is O(N) is the time taken by the algorithm increases linearly when N increases.
The Complexity of an algorithm is O(N^2) if the time taken by the algorithm increases quadratically when N increases.
for (int i = 1; i < n;) {
    i = i * 2;
}
The complexity of this operation is O(log(N))

Lists and Sets |  get  | add   | remove | contains
---------------+-------+-------+--------+---------
ArrayList      | O(1)  |  O(1) |  O(n)  |  O(n)
LinkedList     | O(n)  |  O(1) |  O(1)  |  O(n)
HashSet        | O(1)  |  O(1) |  O(1)  |  O(1)
LinkedHashSet  | O(1)  |  O(1) |  O(1)  |  O(1)
TreeSet        |O(logN)|O(logN)| O(logN)| O(logN)
---------------+-------+-------+--------+---------
Maps
---------------+-------+-------+--------+---------
HashMap        | O(1)  |  O(1) |  O(1)  |  O(1)
LinkedHashMap  | O(1)  |  O(1) |  O(1)  |  O(1)
TreeMap        |O(logN)|O(logN)| O(logN)| O(logN)


Queue           | offer  | peek | pull   | size |
----------------+--------+------+--------+------+
PrioritityQueue | O(logN)| O(1) | O(logN)| O(1) |

Sorting algorithms | Time Complexity | Space Complexity |
-------------------+-----------------+------------------+
MergeSort          |     O(NlogN)    |       O(n)       |
TreeSort           |     O(NlogN)    |       O(n)       |


# Sorting
Trade offs in sorting
What is the complexity of the algorithm used.
How does it scales as the input size increases?
How much space does it occupy?
Does it need extra space to hold information during sorting?
Is the sort stable?
Do equal elements maintain their original order after sorting?
How many comparisions and elements swaps are needed?
Do the algorithm work better with nearly sorted list?
Is the sort adaptive?
Does it breaks early when the list is sorted?

Sorting algorithms
- Selection Sort
- Bubble Sort
- Insertion Sort
- Shell Sort
- Merge Sort
- Quick Sort
- Binary Search


##################
# Data Structure #
##################

# Tree Data Structure

A Binary tree is one where every node can have a maximum of two children. The left and right.
Two binary trees are the same if
1. Every corresponding node has the same value
2. The structure of the tree at every corresponding node is thesame


# Stack Data Structure

A stack is data structure to hold elements such that the last element you add to the stack is first one you access.
LIFO list in first out
Major operations that you performed on the stack are always focused on one end of the stack, called the TOP

Adding new elements to the stack is called -> PUSH -> push an element to the top of a stack
Removing an element from the top a stack is called -> POP -> pop an element from the top of stack
See what element on stack is do not ermove it -> PEEK -> peek at the top of a stack

Peek let's you access the top element in the stack without actually changing the Data Structure

Common operations on stack
PUSH    POP     PEEK

Other operations which are useful
ISEMPTY     ISFULL      SIZE

If you try to POP from an empty element or PUSH into full stack -> It's an ERROR throw an Exception!

The most common operations on a stack involve pushing and popping elements from the TOP.
The operations are on one end of the stack.
A LinkedList match perfectly to build a stack

Performance
PUSH and POP from a stack O(1) constant time complexity.
isEmpty and isFull also O(1)
Size O(1)

Useful
Implementing Undo in application
Implementing back button in browser
Holding the memory for recursive calls in a programing language

+-------+------+-----+------+--------+---------+------+
|       | PUSH | POP | PEEK | isFull | isEmpty | Size |
+-------+------+-----+------+--------+---------+------+
| Stack | O(1) |O(1) | O(1) |  O(1)  |   O(1)  | O(1) |
+-------+------+-----+------+--------+---------+------+


# Queue Data Structure

Queue is a Data Structure where you add elements to the End of the Queue and remove elements
from the beggining of the QUEUE.

FIFO first in first out
LILO last in last out

The operations are performed at two ends. Removal its at the beggining and addition is at the end of the queue.

Adding a new element to the end of the Queue is called
ENQUEUE -> enqueue an element from the queue

Removing an element from the beggining of a queue is called
DEQUEUE -> dequeue an element from the queue

Similar to stack you might just want to see what the first element in a queue is without removing it
PEEK -> Peek at the first element in a queue

The Queue implementation in Java
OFFER -> adds to a queue if space is available

Common operations on the queue
ENQUEUE     DEQUEUE     PEEK

Other operations
ISEMPTY ISFULL OFFER

If you try to dequeue from an empty queue or enqueue into full queue. It's an error throw Exception

The most common operations on queue involve enqueueing and dequeueing elements.
The operations are on both ends of queue.
A LinkedList which is a pointer to head and tail works well.

Performance
Enqueueing and dequeueing implemented in this way is O(1).
IsEmpty isFull O(1)
Space complexity O(N)

Useful
Calls
Queueing job to be printed
Order processing system E-Commerance websites or bank transactions.

+-------+---------+---------+--------+---------+
|       | Enqueue | Dequeue | isFull | isEmpty |
+-------+---------+---------+--------+---------+
| Queue |   O(1)  |   O(1)  |  O(1)  |   O(1)  |
+-------+---------+---------+--------+---------+


#########################
# Garbage Collection GC #
#########################

Java provides automatic memory management through a program called Garbage Collector. "Remove object that are not use"
live object = reachable (referenced by someone else)
dead object = unreachable (unreferenced)
Objects are alocated in the "heap" of java memory
static members, class definition are stored in "method area" Permgen/Metaspace
Garbage Collection is carried out by a daemon hread called "Garbage Collector"
Force GC to happened System.gc (no guaranteed)
When failed to alocated bcause of full heap. Error message java.lang.OutOfMemoryError

Gargage Collector involves
    - Mark : go through all program structure, mark reachable objects as live
    - Delete/Sweep : Delete unreachable objects
    - Compacting : Compact memory by moving around objects

Typed of Garbage Collector
    - Serial Collector : Runs on single thread, useful in basic applications
    - Concurrent Collector : GC execute as application runs, not wait the old generation to full stop the world
      execute only during mark/re-mark phase
    - Parallel Collector : Uses multiple CPUs to perform GC. Multiple threads doing mark/sweep. Does not start until
      heap is full/near-full. "Stop the world" when runs.

Use Concurrent collector, when there is more memory, high number of CPUs, short pauses required
Use paraller collector, when there is less memory, lesser number of CPUs, high throughput required, pauses are OK

java -XX:+UseSerialGC
java -XX:+UseParallelGC
java -XX:+UseConcMarkSweepGC


###############
# Concurrency #
###############
fail-safe do not throw ConcurrentModificationException
fail-fast throw ConcurrentModificationException
volatile - value read always from main memory no cache
synchronized - acquire intrinsic lock on object. Only one object can execute this part of code.
join() - wait until other thread finish executng

wait and notify for inter thread communication. Must be called from sychronized context method, block.

# Process and threads

* In concurrent programming two units of execution process and treads.
* Processing time for a single core is shared among processes and threads, time slicing

* Process : Has a self contained execution environment. Private set of runtime resources.
  Each process has its own memory space. Process can communicate with each others IPC.

* Threads : Lightweight process. Creating a new thread requires fewer resources than creating a new process.
  Exists within a process. Every process has at least one thread.

* join() : method wait until thread to finish

* threads prioritity : importance of a thread to the sheduler. Lower prioritity thread tend to run less often.
  setPrioritity(), getPrioritity(). MAX_PRIORITITY, NORM_PRIORITITY, MIN_PRIORITITY

* yield() : this static method is essentially used to notify the system thet the current thread is willing to
  give up CPU for a while, but sheduler can immediately pick them back. Is put back into the ready queue of the processor,
  and waits for it next turn.


# Start Thread

* Extends Thread - override run() method

* Implements Runnable - override run() method, pas Runnable object to Thread class constructor. Call start method
  on thread object.

* Executor Service - dynamically reuse thread. Check if threads are already working.
  - Executors.newCachedThreadPool() return an executor service that can dynamically reuse threas.
    Before starting a job, it going to check wether there are any threads that finished the job if so reuse them.
    If no create new one, good for processor effective solution
  - Executors.newSingleThreadPool() uses single thread for the job.
  - Executors.newFixedThreadPool() maximize the number of threads. If all the thread are busy we have to wait
    for one to terminate.

  - executorService.execute(Runable)
  - executorService.execute(Callable or Runnable)


# Concurrent Collections

    # ConcurrentHashMap
    * Full concurrency during retreival
    * Reads can happen fast, while writes require lock
    * Whole table is not locked only segment is locked
    * Iterations do not throw concurrent modification exception
    * Null key not allowed
    * Operations are atomic

    # BlockingQueue
    * Interface that represents a queue that is thread safe. put(), take()

    # DelayQueue
    * Like BlockingQueue that implements Delay interface. Cannot put null into it.

    # PrioritityBlockingQueue
    * Iplements Comparable interface. Determine what will be the order of a Queue.


# Threads complications

* Thread interference and memory consistency errors
    - If two thread access the same variable, it is possible for them to get in each others way
      For example tow threads incremanting the same variable at the same time.
      To fic this make sure that section of code is only accessed by one thread at a time, by using synchronized keyword for example.
      But this slows down performance, and can lead to thread contention issues (starvation, livelock, deadlock)

* Thread Contention
    - Deadlock : two thread each is blocked by a lock held by the other
    - Livelock : two thread's don't deadlock, but keep blocking on locks held by each other, neither can progress
    - Starvation : Same thread keep acquiring locks greadly. And cause other threads to be unable to get anything done.


# Semaphores

* Variables that are used to controlling access to common resources, important in OS.
  is a record of how many units of particular resource are available.
  Semaphores track how many resources are free, it does not keep track of which of the resources are free.
  Metexes are binary semaphores. Mutex has a concept of an owner. Only process that locked a mutex is supposed to unlck it.
  Methods acquire() if permit is available take it, release() add a permit.


# Callable and Future

* Returns something from a thread implements Callable instead of Runnable.


# Thread States

* Runnable - create a new thread and call start method
* Blocked - enter synchronized block, lock
* Waiting - after wait()
* Terminated - run method is over


# Concurrent Libraries

    - CountDownLatch : Used to synchronize one ore more tasks by forcing them to wait for completion of a set of operatios
      being performed by other tasks. Give initial count to count down latch object and task that calls await() on that
      oject will block until count reaches zero. The count cannot be reset. Typically use is to divide a problem into "n"
      independetly solveable tasks and create a CountDownLatch with value of "n".
      When each task is finished it calls countDown on Latch. Task waiting to solve call await() on the Latch to hold
      themselves back until it is completed.

    - CyclicBarrier : Used in situation where you want to create a group of tasks to perform work in parallerl plus wait
      until they are still finished before moving on to the next step, like join or countDownLatch.
      Can be reused.


## From Java 8 Book ##

# Concurrent Programming
Runnable describes task that might be executed asynchronously.
Executor plans execute runnable instance.
Callable tasks that return results or throw exception.
Results without synchronization are unpredctable.
Beter use thread safe data structures than use locks.
ConcurrentHashMap is thread safe array allows to updates elements using atomic operations.
To interrupt task set interrupt flag or throw InterruptedException.

Thread is mechanism that allow to execute sequence of instruction, these instructions are delivered by OS.
Couple of threads work in parallel using multiple porcessors of different time slice of the same processor.

Executor executes a task by choosing threads that might be executed with.
Runnable task = () -> {};
Executor exec = Executors...;
exec.execute(task);

Factory method Executor class
Executors.newCachedThreadPool() - each task execute in safe thread, couple of small tasks
Executors.newFixedThreadPool(thread_num); - good for grater amount of tasks
To acquire number of thread based on number of processors.
int processors = Runtime.getRuntime().availableProcessors();

Objects Future and Executor
Callable - Method call() oposite to method run() Runnable interface returns value or throw an Exceptions.
To execute callable there is a need for ExecutorService instance.
ExecutorService exec = ExecutorService.newFixedThreadPool(2);
Callable<V> call = ...;
Future<V> result = exec.submit(call);
Future is an object that represents a calculations, which results will be accessible in a future.

Thread safety
RAM memory are slow, couple of time slower then modern processors. Processor try to collect needed data
in registers or cache memory on main board, and lastly make changes in main memory.
This cache memory is key factor for performance optimization.
Thread Visibility
- final value is visible after initialization
- initial value of static variable is visible after static initialization
- changes variale with volatile keyword are visible
- changes after release a lock are visible for all that acquire this lock.
Volatile keyword - compilator generates needed instructions to make sure that all changes that being applien in one task are
reachable in another.

Chasing
Are problems always when shared variables are modified. Locks to critical section make atomic.

Strategy of safety concurrency
- Avoid schare data between tasks. One task z1, second task z2, z3 = z1 + z2
- Use immutable objects
- Locks allows only one task access to data at a time. Use data ctructures and algorithms from java libraries.

Un modifiable classes
Class in immutable if instance after creation cannot change.
Implement immutable class
- variable with final modificator
- non method can modufy data
- do not allow to leack modification
- Do not allow to this refernece pass outside constructor

Concurrent Algorithms
* Parallel Strams
Long results = coll.parallelStream().filter(s->s.startsWith('a')).count();
ParallelStream method returns parallel stream. Stream is parted on segments.
Filtering and counting is executed for each segments and results are joined together without your further interactions.
* Parralel operations on arrays
Arrays operations part array on segments, parallelly process them and join results.
Arrays.parrarelSetAll(), parallelSort()
Process array into a stream, long sum = IntStream.of(value).parallel().sum();

Thread safe data structures
ConcurrentHashMap
Map on which operations are thread safe. Can support large number of parallel read and some number of parallel reads.
To actualiza data compute method. This method is Atomic, no other thread can modify map content while executing operation.
BlockingQueues
Is one of the most commonly used tool for synchronized work. One task put element into the queue, while take task
take element fro a queue. Allows to safety pass tasks from one task to another.
LinkedBlockingQueue, ArrayBlockingQueue.
ConcurrentSkipListMap - compare keys.
ConcurrentSkipListSet
CopyOnWriteArrayList, CopyOnWriteArraySet - are thread safe thanks the fact that all methods that modify collection
make copy used array. Good in situation when number of threads go through queue is larger than number of thread that modify queue.

Atomic Values
AtomicLong nextNumber = new AtomicLong();
long id = nextWord.incrementAndGet();
Atomic operation, load data, modify data and save data cannot be interrupted in between.

###################
# Design Patterns #
###################

* Design Patterns are canonical solutions to recuring problems
* Creational Patterns "How should object be created"
    - Factory, AbstractFactory, Singleton, Builder, Prototype, Dependency Injection
* Behavioral Patterns "How should object behave and interact with each other"
    - Strategy, Template, Iterator, Command, Chain of Responsibility, Memento, Visitor, State, Mediator, Observer
* Structural Patterns "How should classes behave and interact with each other"
    - Decorator, Adapter, Facade, Composite, Flyweight, Bridge, Proxy
* Concurrency Pattern "How should specific situation be handled in multithreading"
    - Double checked locking
* Model View Controller "Architectural pattern"

* Libraries and Frameworks are both code written by others that we can use.
* Design Patterns are proven ideas for solving common problems.
* Code usually calls libraries and is often called by frameworks, but is stractured using Design Patterns


# Creational

* How objects are constructed
* Decouple the construction of an action from its use
* Hide implementation of an object only reveal its interface
* Defer instantiation until run time
* Families of related objects that must be used together
* Allow creation of finite number of instances


# Behavioral

* How do objects behave and interact with each other
* How logical unit (classes) as whole interacts with the outside world
* Iterator pattern - here logical unit includes 1 class Iterator class. This pattern governs how the
    is used by the client (the outside world)


# Structural

* How classes within the logical unit interacts with each other
* MVC pattern - logical unit includes 3 classes model, view, controller
    The pattern governs how the Model, View, Controller interact with each other
    If the interaction etween the M, V, C were change, the UI would not look or behave any different !


# Design Principle #1 : Relay on Interfaces, not implementation

"Program to an interface not implementation" decorator, iterator, adapter

Interface is a surface that a unit offers to outside world.
That unit could be a single class, or even be a collection of classes.
The implementation is a guts of that unit.
Never get assumption about content of any unit.
ArrayList<String> list = new ArrayList<>(), wrong
List<String> list = new ArrayList<>(), correct


# Design Principle #2 : The Open / Close Principle

"Classes should be open for extension but closed for modfication"

Once you have written a class, it's done. Never add enything to it after that.
No new member variables, no new methods, no new interfaces implemented, No modification.
But other code should be able to use your class in new ways, New applications via extension.

* Inheritance, template pattern
    - If you structure your code into abstract base class, other classes can find
      new way to use it via Inheritance

* Delegation, observer, MVC, Chain of Responsibility
    - If you fire events and expose properties, other code can listen in, and use your code via Delegation

* Composition, strategy pattern
    - If you take in member variale to determine behavior, you allow extension via Composition


# Design Principle #3 : Principle of Least Knowledge

"Only talk to friends, don't talk to strangers"

Only make method calls to friends.
friends - object passed in as parameter to methods of your classes. Object created insde your class.
Code should never include multiple '.' operators in the same function call.
int friendNumber = media.getRelatives().getFriend(), not OK
int firndNumber = media.getFriend(), OK
But this rule is not always a case.
Summarized, each unit should have only limited knowledge about other units. Each unit should only tolk to its friend.


# Design Principle #4 : Dependency Injection

"Depend on abstraction never on details"
Used technique to set member variables of objects on the fly.


# Design Principle #5 : Hollywood Principle

"Don't call us we will call you"
Class notifies other class of changes when they occurs via events or messages.
Idea high-level component calling low-level is used components in frameworks.


# MVC Paradigm

Model View Controller is an architectural pattern. In Java API Swing.
Basic idea of MVC is to separate data from its representation, separating data from its manipulation,
allowing different simultaneous representations of the same data.
MediaPlayer Example. Controller a slider to adjust volume in a media player app. Model the mp4 file of a movie
to be played in a media player app. View the area of the media-player app that actually displays video.
User sees the model through a view, and manipulates it via the controller.


# What is a basic point of observer pattern

An object announces updates to its value, and other objects can read to these updates.


# When a publisher fires an update, how do subscriber bacome aware of it.

The publisher has a list of listeners, and Java cycles through them and Executes the callback function they had specified.


# How are properties and bindings different from eah other.

Properties are ONE:ONE, bindings are ONE:MANY


# How Observer and MVC related

The View act as publisher, controller as subscriber




















