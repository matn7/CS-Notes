################
# Web Services #
################

# Web service is a service offered over the web i.e. HTTP. Whenever we browse the internet we are making
use of inumerable web services.
When type google.com:
- Browser invoke a get request on google.com
- google.com returns a HTTP response with the HTML content to show
- Browser understand the HTML content and renders it for user
Browser invoking a GET request and google.com server is responding with HTTP response.


# What are important parts of a web service?
Important parts:
- Service Provider - google.com is the service provider. Handles the request and sends response back
- Service Consumer - Browser is a service consumer. Creates regest, invokes service process and response
- Data Exchange Format - data exchange in this example is done by HTTP portocol. Data can be XML, JSON, HTML, Text


# Advantages of web service?
- Re-use web service avoid the need to implement business logic repeatedly. If we expose WS other apps can re use functionality
- Modularity
- Language Neutral
- Basics of SAO (service oriented architecture)


# Different type of web services?
WS are classified usually by data exchange format. Two popular type of WS:
- SOAP
- RESTFUL


# What are SOAP WS
In SOAP data exchange format (request and response) happens using SOAP format. SOAP is based on XML.
SOAP format defines SOAP-Envelope which envelopes the entire document.
SOAR header contains any information needed to identify the request. Part of authentication, authorization.
SOAP body contains real XML content of request or response.
SOAP fault in case of error response.


# What s a WSDL?
WSDL defines the format for SOAP Message exchange between the Server (Service Provider) and the client (Service consumer)
A WSDL defines:
- What are the different services exposed by the server?
- How can a service (operation) be called? What url use? Endpoint
- What should be the structure of request xml?
- What should be the structure of response xml?


# What is marschalling and unmarschalling? How do JAXB and XML help with this?
SOAP WS use SOAP based XML format for communication. Java application work with beans i.e. Java objects.
For an application to expose or consume SOAP WS, we need two things:
- Convert Java Object to SOAP XML. This is called Marshalling
- Convert SOAP XML to Java Object. This is called Un Marshalling
JAXB and XML Beans are frameworks which enable use to do marshalling and unmarshalling easy.


# How do you handle security for WS?
At two levels transport level and application level
- At transport level, SSL is used to exchange certificates (HTTPS). This ensures that the server
and client are mutually authenticated.
- At the application level security is implemented by transferring encrypted info (dygital signature) in the message header (SOAP header).


# What are the popular Java Specifications for Web Services?
JAX-WS for SOAP WS
JAX-RS for REST WS


# What is Service Oriented Architecture (SAO)?
Service Oriented architecture is an architectural style where applications are built on top of language neutral
loosely coupled, independent, reusable components.
Major components of SOAP are:
- User interface layer.
- Business process layer
- Services


# What is the REST WS?
Any services that satisfies REST constraints are called RESTful WS.


# Important constraints of REST WS
- Client-Server
- The interface (URL) - uniform and exposing resources.
- The service is stateless - the same result
- Service result should be cacheable
- Should assume layered architecture


# Richardson Maturity Level?
- Level 0 - Expose SOAP WS in REST style. Expose action based service using REST
- Level 1 - Expose resources with proper URI.
- Level 2 - Resources use URI's and HTTPmethods. Update account PUT, create POST, GET, DELETE
- Level 3 - HATEOAS not only the info being requested but also info about next possible ections that the
  WS can do. Example return user details plus info how get users previous post, retreive list, sort etc.


# Best practice with REST API
- Does request makes sense to api consumer
- URI should represent resources
- Use HTTP methods


# HTTP methods in REST bst practice
- GET : should not update anything. Should be indepotent (same result in multiple calls). Return codes 200, 404, 400
- POST : should create new resource. Return JSON with link to new resource. Return codes 201
- PUT : update resource. Code 200
- DELETE : Delete resource


# Explain JAX-RS
JAX-RS is a Java specification for RESTful WS implemented by all JEE compliant WS.
Important annotations:
@ApplicationPath("/") - define URL path
@GET, @POST - define HTTP methods invokes that methods
@Produce(MediaType.APPLICATION_JSON) - defines output format of REST WS
@Path("/{id}") on a method and @PathParam("id") on method parameter. Dynamic parameter in REST URL
@Path("{user_id}/followers/{follower_id}")
@QueryParam("page") method parameter /user?page=10
Useful methods:
-Response.OK(jsonBuilder.build()).build() - returns JSON response with status code
-JSON.createObjectBuilder).add("id", user.getId()) creates a user object


# Advantages of REST WS
Lightweight
Easy to expose
Most use HTTP protocol
High Performance


# Difference between JSON and REST
REST is architectural principle.
SOAP is message exchange format.
REST is build over siple HTTP protocol. SOAP arem more complex.
REST better performance and scalability. REST reads can be cached SOAP cannot.
REST permits many different data formats SOAP only XML.
SOAP services have well defined structure and interface (WSDL)
SOAP is based on well defined structure (WS-Security, WS-Atomic Transaction ad WS-Reliable messaging)


#######################
# JEE Design Patterns #
#######################

Net profile - set of most complementary technologies to build we apps:
Servlets, JSF, JSP, EJB, JTA, JPA

Convention over configuration - process of building web app without to much configuration complications.

Component Model - entities, Java Beans, EJB Beans, Manages Beans, Servlets, SOAP, REST WS

CDI - separates relation between objects. Dependency injection to object instead create new object using new operator
 Context - differentiate EJB beans from CDI. CDI beans are created in context and scope and exists till its destruction.
 @ApplicationScope, @ConversationScope, @SessionScope, @RequestScope

Interceptors - logical separates and store methods calls to root and call sufficient methods: logging, security

Dependency injection CDI - instead of create dependencies and new objects using new keyword. Needed resources are injected to target object.
- client does not need to know about different representations of injected resources
- easier unit testing using dummies (atrap) object
- configuration can be placed outside
- loosly coupled architecture easier create socket services
You can inject
- POJO
- business resources data, queues
- EJB references
- Session Beans
- EntityManager objects
- Web service references

CDI can exists without EJB container. Provides factory and injection of any bean
EJB need to have EJB container. Container add additional services like transaction, concurrency
CDI is lighter and much stronger but less functional than EJB for POJO objects

CDI Beans
- Need to have no argument constructor or container with @Inject annotation
- cannot be non static inner class
- Bean cannot be defined as EJB

Contexts and Scopes
- @RequestScoped - user HTTP request
- @SessionScoped - user HTTP session
- @ApplicationScoped - state schared with all app users
- @ConversationScoped - controled by programmer

AOP Aspect oriented programming (interceptors) - conception which determine the order of executing code based on aspects.
Eah aspect stores executing of program and before continue add own function.

Cross cutting concerns - events, securitt, Spring, AspectJ, Servlet Filters
AOP is not design pattern but way of programming
@WebFilter(fileName="TimeOfDayFilter", urlPatterns={"/*"})
public class SecurityFilter implements FIlter {
...
}
Advice - decoration object
Pointcut - point of execution of aspect

# Data Access Object
DAO is to provide convenient interface to data access.
Is used to standarize code to access to persistent storage. DAO manages connection to source of data
in order to save and download data.
Abstraction and encapsulation of data source separates implementation of application from source of data.
Separates business logic from implementation of data source.
DAO pattern packs CRUD operation in interface which is implemented by some concrete class.
DAO implmentation use low level interfaces API like JPA and Hibernate.

Implementation consists of
- DAO interface
- Concrete implementation of DAO interface
- DAO factory
- DTA object

API JPA and ORM
- JPA interface is ised to control interaction of program and data source
- Determines way of access to information and save them and manage them between object and source
- JPA does not allow on execute CRUD operation or anything data manage related
- Key in JPA is entity. Entity is longterm object which we can save in data base no as serializable object but as data
- POJO object with adnotations and mapped on fields in data source

No need to add more adnotations. This way is calling ORM (Object relational mapping)

@Entity
public class Movie implements Serializable {
    private static final long serialVersionUID = -8789769878978L;
    @Id
    @GeneratedValue
    private Long id;
    private Long title;
    public Movie() {}
    // getters setters
}

- Entity class need to have no argument constructor, which can be public private
- It must be a class. Enumeration, iterface or final class is not allowed
- final could not be any variable or setter method
- Class must implements Serializable interface

Primary key could be
- primitive Java type
- Java wrapper
- primaty type array
- Java type String, BigInteger, Data

// DAO interface which defines primary CRUD methods
public interface MovieDAO {
    public void addMovie(Movie movie);
    public Movie getMove(in id);
    public void deleteMovie(int id);
    public void updateMovie(Movie movie);
    pulic List<Movie> getAllMovies();
}

EntityaMnager - object defines with context of saving defined in persistence.xml
Interface API EntityManager provides functions to create, delete, save and delete and make calls

public class MovieDaoImpl implments MovieDAO {
    private EntityManager em;
    public MovieDaoImpl(EntityManager em) {
        this.em = em;
    }
    @Override
    public void addMovie(Movie movie) {
        em.persist(movie);
    }
    ...
}

// DAO Factory
@ApplicationScoped
public class MovieDaoFactory {
    @PersistenceContext(unitName="moviePU")
    private EntityManager em;

    @Produces
    public MovieDAO createMovieDAO() {
        return new MovieDaoImpl(em);
    }
}

Persistence unit - List of entities in application defined in persistence.xml file.
FTA
Provider - factory to ENtityMagager copies
Class - entity class used in application
properties - data base connection

// persistence.xml
<persistence-unit name="MoviePU" transaction-type="JTA">
    <provider>PersistenceProvider</provider>
    <jta-data-source>jdbc</jta-data-source>
    <class>Movie</class>
</persistence-unit>

// DAO type safe
public interface BaseDAO<E,K> {
    public void create(E entity);
    public Movie retreive(K id);
    public void update(E entity);
    public void delete(K id);
}

// implementation of DAO
public interface MovieDAO extends BaseDAO<Movie, Integer> {
    public List<Movie> findAllMovies();
}

########
# REST #
########
- Determines style of representation and send data. Consists of 6 elements about data, their interactions on the internet.
- Set of conventions, styles and techniques which was determines by tears of practices
- REST can be treated as formatting style of identifiers URI which represents the resources provided and stored by app.
- Resources are represented by Nouns and used in combine with HTTP methods to make REST URI identifiers
- HTTP Get gets the resources
- HTTP POST creates resources
- URI represents resources on server, HTTP method determines an execution process of this resource (delete, retreive)
- JSON data format but can also be other

6 REST conditions
- Client-Server
- Common interface
- Stateless : no data state should be stored
- Capability of save data in buffer
- Layering system
- Code on demand

Richardson maturity level
- Level 0 : send and get demands on one URI. Model RPC
- Level 1 : different layer communication is possible. POST resources/123 but only one HTTP method
- Level 2 : http verbs. Http verbs and nonun resources. Use all HTP protocol (GET, POST, PUT, DELETE)
- Level 3 : hypermedial control. HATEOAS get client resources, and next step to further retreive them

Name of resources should be nouns
Activities to execte as HTTP verbs

Indepondent is trait as all client calls to specific URI identifier always shall provide the same result.

- GET : to get data. JSON, XML. 200 OK return code. 404 not found or 400 bad request.
/users/123456/followers

- POST : create resources in specific context. Http 2001 created plus reference to newely created resources.
204 no content
/users/123456/posts

- PUT : modify resources. 200 OK
/users/123456

- DELETE : deletes resource. 200 OK.
/users/123456


REST in Java EE
@Path - defines context that identifies URI and class or mehod to retreive process this request
@GET, @POST, @PUT, @DELETE
@ApplicationPath

// Implementation of REST API GET /users
@ApplicationPath("/")
@Path("users")
publicclass User extends Application {
    @GET
    public String getUser() {
        return "Users representation";
    }
}

// Send to client response with JSON data
@ApplicationPath("/")
@Path("users")
public class Users extends Application {
    @GET
    @Produces(MediaType.APPLICATION_JSON)
    public Response getUsers() {
        ArrayList<User> allUsers = this.findAllUsers();
        JsonArrayBuilder json = Json.createArrayBuilder();
        ...
    }
    return Response.OK(json.builder()).build();
}

@GET
@Path("/{id}")
@Produces(MadiaType.APPLICATION_JSON)
public Response getUser(@PathParam("id") String id) {
    ..
    return Response.ok(json.build()).build();
}


##########
# Spring #
##########

Bean Scope
- Singleton : single instance of bean
- Prototype : return new instance every time it is created
- Request : new instance every HTTP request
- Session : new Http session, new instance
- GlobalSession : single instance per global session

Kinds of injection
- Property based injection
@Autowired
private NotificationServce notification;
- Setter based injection
@Autowired
public void setNotificationService(NotificationServce notification) {
    this.notification = notification;
}
- Constructor based injection
@Autowired
public PageController(NotificationServce notification) {
    this.notification = notification;
}

@SpringBootApplication = @Configuration + @EnableAutoConfiguration + @ComponentScan

Incoming request  +------------------+ Delegate Request  +------------+
----------------->+                  +------------------>+            | Handle Request
                  | Front Controller |    +-------+      | Controller |
<-----------------+                  +<---| model |------+            | Create model
Resturn Response  +--+------------+--+    +-------+      +------------+
                     |            |        Delegate
             Return  |        +---+---+    rendering
             control |        | model |    of response
                     |        +---+---+
                     |            |
                     |            |
                  +--+------------+--+
                  |   View Template  |          Servlet engine (JBoss, Tomcat)
                  +------------------+